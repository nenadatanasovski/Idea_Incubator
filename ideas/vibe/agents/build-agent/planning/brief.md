# Build Agent Brief

## Metadata

| Field          | Value       |
| -------------- | ----------- |
| **ID**         | build-agent |
| **Title**      | Build Agent |
| **Complexity** | complex     |
| **Author**     | Spec Agent  |
| **Created**    | 2026-01-11  |

---

## Problem

After the Spec Agent generates implementation specifications and atomic tasks, there is no automated way to execute these tasks. Currently, a human developer must:

1. Read each task from tasks.md
2. Understand the requirements and gotchas
3. Write the code manually
4. Run validation commands
5. Handle failures and retry

This manual process is slow, error-prone, and doesn't scale. We need an agent that can autonomously execute implementation tasks generated by Spec Agent.

---

## Solution

Build Agent is an autonomous code generation and execution system that:

1. **Reads task specifications** from tasks.md files
2. **Primes context** with relevant project files and patterns
3. **Generates code** using Claude API based on task requirements
4. **Writes files** safely with locking and backup
5. **Validates output** by running task validation commands
6. **Handles failures** with retry logic and checkpoints
7. **Reports progress** through the communication system

Build Agent executes tasks in dependency order, ensuring earlier tasks complete successfully before dependent tasks begin.

---

## MVP Scope

**In Scope:**

- Load and parse tasks.md files
- Execute tasks in dependency order
- Generate code using Claude API
- Write files with safety checks
- Run validation commands
- Basic retry on failure (3 attempts)
- Checkpoint after each successful task
- Integration with Communication Hub for questions
- Git integration for commits

**Out of Scope:**

- Parallel task execution
- Automatic rollback of failed builds
- Complex conflict resolution
- Self-healing from partial failures
- Performance optimization
- Caching of generated code

---

## Constraints

1. Must use existing Communication Hub for questions
2. Must follow project patterns in CLAUDE.md
3. Must not modify files outside task scope
4. Must validate each task before moving to next
5. Must create checkpoints for recovery
6. Must use better-sqlite3 for any database operations
7. Must integrate with existing WebSocket for progress updates

---

## Success Criteria

1. Can execute all tasks from a simple (5-8 task) spec
2. Can execute all tasks from a medium (10-15 task) spec
3. Validation commands pass for generated code
4. TypeScript compiles without errors
5. Creates checkpoint after each task
6. Can resume from checkpoint after interruption
7. Asks clarifying questions through Communication Hub when blocked

---

## Architecture Hints

```
Build Agent Components:
├── context-primer.ts     - Load relevant context for task
├── task-executor.ts      - Main execution loop
├── code-generator.ts     - Claude API integration for code
├── file-writer.ts        - Safe file operations
├── validation-runner.ts  - Run validation commands
├── checkpoint-manager.ts - Save/restore state
├── retry-handler.ts      - Exponential backoff on failure
└── git-integration.ts    - Commit after successful tasks
```

**Execution Flow:**

```
1. Load tasks.md
2. Order by dependencies
3. For each task:
   a. Prime context (CLAUDE.md, related files, gotchas)
   b. Generate code with Claude
   c. Write file (with backup)
   d. Run validation
   e. If fail: retry up to 3x
   f. If still fail: ask human via Communication Hub
   g. Create checkpoint
   h. Commit to git (optional)
4. Report completion
```

---

## Database Schema

```sql
-- Build execution tracking
CREATE TABLE IF NOT EXISTS build_executions (
    id TEXT PRIMARY KEY,
    spec_id TEXT NOT NULL,
    status TEXT DEFAULT 'pending',
    current_task_id TEXT,
    started_at TEXT,
    completed_at TEXT,
    error_message TEXT
);

-- Task execution history
CREATE TABLE IF NOT EXISTS task_executions (
    id TEXT PRIMARY KEY,
    build_id TEXT NOT NULL,
    task_id TEXT NOT NULL,
    attempt INTEGER DEFAULT 1,
    status TEXT DEFAULT 'pending',
    started_at TEXT,
    completed_at TEXT,
    generated_code TEXT,
    validation_output TEXT,
    error_message TEXT,
    FOREIGN KEY (build_id) REFERENCES build_executions(id)
);

-- Checkpoints for recovery
CREATE TABLE IF NOT EXISTS build_checkpoints (
    id TEXT PRIMARY KEY,
    build_id TEXT NOT NULL,
    task_id TEXT NOT NULL,
    state_json TEXT NOT NULL,
    created_at TEXT DEFAULT (datetime('now')),
    FOREIGN KEY (build_id) REFERENCES build_executions(id)
);
```

---

## API Design

| Endpoint                      | Method | Description                |
| ----------------------------- | ------ | -------------------------- |
| /api/builds                   | POST   | Start new build from spec  |
| /api/builds/:id               | GET    | Get build status           |
| /api/builds/:id/tasks         | GET    | Get task execution history |
| /api/builds/:id/resume        | POST   | Resume from checkpoint     |
| /api/builds/:id/cancel        | POST   | Cancel running build       |
| /api/builds/:id/retry/:taskId | POST   | Retry failed task          |

---

## Risk Mitigation

1. **File corruption**: Write to temp file first, then atomic rename
2. **Partial execution**: Checkpoints after each task
3. **Bad code generation**: Validation before commit
4. **Infinite loops**: Max retry limit (3) with exponential backoff
5. **Resource exhaustion**: Token limits per task
