/**
 * Project Folder API Routes
 * Part of: Phase 9 - Project Folder & Spec Output (T9.5)
 *
 * Provides API endpoints for:
 * - Listing files in project folder
 * - Reading file content
 * - Creating new files
 * - Managing spec versions
 */

import { Router } from "express";
import type { Request, Response } from "express";
import * as fs from "fs";
import * as path from "path";
import { z } from "zod";
import {
  getIdeaFolderPath,
  ideaFolderExists,
} from "../../../utils/folder-structure.js";
import {
  getSpecBySession,
  getSpecSections,
  generateSpec,
  saveSpecToFile,
  getSpecHistoryFromFile,
  loadSpecFromFile,
} from "../../../agents/ideation/spec-generator.js";
import { timeoutMiddleware } from "./shared.js";

export const projectRouter = Router();

// Apply timeout middleware
projectRouter.use(timeoutMiddleware);

// ============================================================================
// Types
// ============================================================================

interface FileNode {
  name: string;
  path: string;
  type: "file" | "directory";
  size?: number;
  modifiedAt?: string;
  isGenerated?: boolean;
  hasBlockReferences?: boolean;
  blockReferenceCount?: number;
  children?: FileNode[];
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Check if a file is AI-generated by looking for markers
 */
function isGeneratedFile(filePath: string): boolean {
  try {
    const content = fs.readFileSync(filePath, "utf-8");
    // Check for common AI-generated markers
    return (
      content.includes("Generated from ideation session") ||
      content.includes("AI-Generated") ||
      content.includes("graph_snapshot_id:") ||
      content.includes("<!-- Agent fills")
    );
  } catch {
    return false;
  }
}

/**
 * Count block references in a file
 */
function countBlockReferences(filePath: string): number {
  try {
    const content = fs.readFileSync(filePath, "utf-8");
    // Look for block_references in YAML frontmatter
    const match = content.match(/block_references:\n((?:\s+-\s+\S+\n)*)/);
    if (match && match[1]) {
      return (match[1].match(/-\s+/g) || []).length;
    }
    return 0;
  } catch {
    return 0;
  }
}

/**
 * Build a file tree recursively
 */
function buildFileTree(
  dirPath: string,
  relativePath: string = "",
  depth: number = 0,
  maxDepth: number = 10,
): FileNode[] {
  if (depth > maxDepth) {
    return [];
  }

  const nodes: FileNode[] = [];

  try {
    const entries = fs.readdirSync(dirPath, { withFileTypes: true });

    for (const entry of entries) {
      // Skip hidden files except .metadata
      if (entry.name.startsWith(".") && entry.name !== ".metadata") {
        continue;
      }

      const entryPath = path.join(dirPath, entry.name);
      const entryRelativePath = relativePath
        ? `${relativePath}/${entry.name}`
        : entry.name;

      if (entry.isDirectory()) {
        const children = buildFileTree(
          entryPath,
          entryRelativePath,
          depth + 1,
          maxDepth,
        );

        nodes.push({
          name: entry.name,
          path: entryRelativePath,
          type: "directory",
          children,
        });
      } else if (entry.isFile()) {
        const stats = fs.statSync(entryPath);
        const isGenerated = isGeneratedFile(entryPath);
        const blockRefCount = countBlockReferences(entryPath);

        nodes.push({
          name: entry.name,
          path: entryRelativePath,
          type: "file",
          size: stats.size,
          modifiedAt: stats.mtime.toISOString(),
          isGenerated,
          hasBlockReferences: blockRefCount > 0,
          blockReferenceCount: blockRefCount,
        });
      }
    }

    // Sort: directories first, then alphabetically
    nodes.sort((a, b) => {
      if (a.type !== b.type) {
        return a.type === "directory" ? -1 : 1;
      }
      return a.name.localeCompare(b.name);
    });
  } catch (error) {
    console.error(`[ProjectRoutes] Error reading directory ${dirPath}:`, error);
  }

  return nodes;
}

// ============================================================================
// GET /project/:userSlug/:ideaSlug/files
// ============================================================================
// List all files in the project folder with tree structure

projectRouter.get(
  "/:userSlug/:ideaSlug/files",
  async (req: Request, res: Response) => {
    try {
      const { userSlug, ideaSlug } = req.params;

      if (!userSlug || !ideaSlug) {
        return res.status(400).json({
          error: "Validation error",
          message: "userSlug and ideaSlug are required",
        });
      }

      // Check if idea folder exists
      if (!ideaFolderExists(userSlug, ideaSlug)) {
        return res.status(404).json({
          error: "Not found",
          message: `Idea folder not found: ${ideaSlug}`,
        });
      }

      const ideaFolderPath = getIdeaFolderPath(userSlug, ideaSlug);

      console.log(`[ProjectRoutes] Listing files for ${userSlug}/${ideaSlug}`);

      const files = buildFileTree(ideaFolderPath);

      return res.json({
        success: true,
        data: {
          files,
          rootPath: ideaFolderPath,
        },
      });
    } catch (error) {
      console.error("[ProjectRoutes] Error listing files:", error);
      return res.status(500).json({
        error: "Internal server error",
        message: error instanceof Error ? error.message : "Unknown error",
      });
    }
  },
);

// ============================================================================
// GET /project/:userSlug/:ideaSlug/files/:path(*)
// ============================================================================
// Get content of a specific file

projectRouter.get(
  "/:userSlug/:ideaSlug/files/:filePath(*)",
  async (req: Request, res: Response) => {
    try {
      const { userSlug, ideaSlug, filePath } = req.params;

      if (!userSlug || !ideaSlug || !filePath) {
        return res.status(400).json({
          error: "Validation error",
          message: "userSlug, ideaSlug, and filePath are required",
        });
      }

      // Check if idea folder exists
      if (!ideaFolderExists(userSlug, ideaSlug)) {
        return res.status(404).json({
          error: "Not found",
          message: `Idea folder not found: ${ideaSlug}`,
        });
      }

      const ideaFolderPath = getIdeaFolderPath(userSlug, ideaSlug);
      const fullPath = path.join(ideaFolderPath, filePath);

      // Security check: ensure path is within idea folder
      const resolvedPath = path.resolve(fullPath);
      if (!resolvedPath.startsWith(path.resolve(ideaFolderPath))) {
        return res.status(403).json({
          error: "Forbidden",
          message: "Path traversal not allowed",
        });
      }

      // Check if file exists
      if (!fs.existsSync(fullPath)) {
        return res.status(404).json({
          error: "Not found",
          message: `File not found: ${filePath}`,
        });
      }

      const stats = fs.statSync(fullPath);

      if (stats.isDirectory()) {
        return res.status(400).json({
          error: "Bad request",
          message: "Cannot read directory content",
        });
      }

      console.log(
        `[ProjectRoutes] Reading file ${filePath} for ${userSlug}/${ideaSlug}`,
      );

      const content = fs.readFileSync(fullPath, "utf-8");

      return res.json({
        success: true,
        data: {
          path: filePath,
          content,
          size: stats.size,
          modifiedAt: stats.mtime.toISOString(),
          isGenerated: isGeneratedFile(fullPath),
          blockReferenceCount: countBlockReferences(fullPath),
        },
      });
    } catch (error) {
      console.error("[ProjectRoutes] Error reading file:", error);
      return res.status(500).json({
        error: "Internal server error",
        message: error instanceof Error ? error.message : "Unknown error",
      });
    }
  },
);

// ============================================================================
// POST /project/:userSlug/:ideaSlug/files
// ============================================================================
// Create a new file

const CreateFileSchema = z.object({
  path: z.string().min(1, "path is required"),
  content: z.string(),
});

projectRouter.post(
  "/:userSlug/:ideaSlug/files",
  async (req: Request, res: Response) => {
    try {
      const { userSlug, ideaSlug } = req.params;

      if (!userSlug || !ideaSlug) {
        return res.status(400).json({
          error: "Validation error",
          message: "userSlug and ideaSlug are required",
        });
      }

      const parseResult = CreateFileSchema.safeParse(req.body);
      if (!parseResult.success) {
        return res.status(400).json({
          error: "Validation error",
          details: parseResult.error.issues,
        });
      }

      const { path: filePath, content } = parseResult.data;

      // Check if idea folder exists
      if (!ideaFolderExists(userSlug, ideaSlug)) {
        return res.status(404).json({
          error: "Not found",
          message: `Idea folder not found: ${ideaSlug}`,
        });
      }

      const ideaFolderPath = getIdeaFolderPath(userSlug, ideaSlug);
      const fullPath = path.join(ideaFolderPath, filePath);

      // Security check: ensure path is within idea folder
      const resolvedPath = path.resolve(fullPath);
      if (!resolvedPath.startsWith(path.resolve(ideaFolderPath))) {
        return res.status(403).json({
          error: "Forbidden",
          message: "Path traversal not allowed",
        });
      }

      // Ensure parent directory exists
      const parentDir = path.dirname(fullPath);
      if (!fs.existsSync(parentDir)) {
        fs.mkdirSync(parentDir, { recursive: true });
      }

      console.log(
        `[ProjectRoutes] Creating file ${filePath} for ${userSlug}/${ideaSlug}`,
      );

      fs.writeFileSync(fullPath, content, "utf-8");

      const stats = fs.statSync(fullPath);

      return res.status(201).json({
        success: true,
        data: {
          path: filePath,
          size: stats.size,
          modifiedAt: stats.mtime.toISOString(),
        },
      });
    } catch (error) {
      console.error("[ProjectRoutes] Error creating file:", error);
      return res.status(500).json({
        error: "Internal server error",
        message: error instanceof Error ? error.message : "Unknown error",
      });
    }
  },
);

// ============================================================================
// GET /project/:userSlug/:ideaSlug/spec
// ============================================================================
// Get current spec for the project

projectRouter.get(
  "/:userSlug/:ideaSlug/spec",
  async (req: Request, res: Response) => {
    try {
      const { userSlug, ideaSlug } = req.params;
      const { sessionId } = req.query;

      if (!userSlug || !ideaSlug) {
        return res.status(400).json({
          error: "Validation error",
          message: "userSlug and ideaSlug are required",
        });
      }

      console.log(`[ProjectRoutes] Getting spec for ${userSlug}/${ideaSlug}`);

      // Try to get spec from file first
      const specContent = loadSpecFromFile(userSlug, ideaSlug);
      const specHistory = getSpecHistoryFromFile(userSlug, ideaSlug);

      if (specContent) {
        return res.json({
          success: true,
          data: {
            source: "file",
            content: specContent,
            currentVersion: specHistory?.currentVersion || 1,
            historyCount: specHistory?.history.length || 1,
          },
        });
      }

      // Fall back to database spec if file not found
      if (sessionId && typeof sessionId === "string") {
        const spec = await getSpecBySession(sessionId);
        if (spec) {
          const sections = await getSpecSections(spec.id);
          return res.json({
            success: true,
            data: {
              source: "database",
              spec,
              sections,
            },
          });
        }
      }

      return res.status(404).json({
        error: "Not found",
        message: "No spec found for this project",
      });
    } catch (error) {
      console.error("[ProjectRoutes] Error getting spec:", error);
      return res.status(500).json({
        error: "Internal server error",
        message: error instanceof Error ? error.message : "Unknown error",
      });
    }
  },
);

// ============================================================================
// GET /project/:userSlug/:ideaSlug/spec/history
// ============================================================================
// Get spec version history

projectRouter.get(
  "/:userSlug/:ideaSlug/spec/history",
  async (req: Request, res: Response) => {
    try {
      const { userSlug, ideaSlug } = req.params;

      if (!userSlug || !ideaSlug) {
        return res.status(400).json({
          error: "Validation error",
          message: "userSlug and ideaSlug are required",
        });
      }

      console.log(
        `[ProjectRoutes] Getting spec history for ${userSlug}/${ideaSlug}`,
      );

      const specHistory = getSpecHistoryFromFile(userSlug, ideaSlug);

      if (!specHistory) {
        return res.status(404).json({
          error: "Not found",
          message: "No spec history found for this project",
        });
      }

      return res.json({
        success: true,
        data: {
          currentVersion: specHistory.currentVersion,
          versions: specHistory.history.map((entry) => ({
            version: entry.version,
            createdAt: entry.createdAt,
            workflowState: entry.workflowState,
            filename: entry.filename,
          })),
        },
      });
    } catch (error) {
      console.error("[ProjectRoutes] Error getting spec history:", error);
      return res.status(500).json({
        error: "Internal server error",
        message: error instanceof Error ? error.message : "Unknown error",
      });
    }
  },
);

// ============================================================================
// GET /project/:userSlug/:ideaSlug/spec/version/:version
// ============================================================================
// Get a specific version of the spec

projectRouter.get(
  "/:userSlug/:ideaSlug/spec/version/:version",
  async (req: Request, res: Response) => {
    try {
      const { userSlug, ideaSlug, version } = req.params;

      if (!userSlug || !ideaSlug || !version) {
        return res.status(400).json({
          error: "Validation error",
          message: "userSlug, ideaSlug, and version are required",
        });
      }

      const versionNum = parseInt(version, 10);
      if (isNaN(versionNum) || versionNum < 1) {
        return res.status(400).json({
          error: "Validation error",
          message: "version must be a positive integer",
        });
      }

      console.log(
        `[ProjectRoutes] Getting spec version ${versionNum} for ${userSlug}/${ideaSlug}`,
      );

      const specContent = loadSpecFromFile(userSlug, ideaSlug, versionNum);

      if (!specContent) {
        return res.status(404).json({
          error: "Not found",
          message: `Spec version ${versionNum} not found`,
        });
      }

      return res.json({
        success: true,
        data: {
          version: versionNum,
          content: specContent,
        },
      });
    } catch (error) {
      console.error("[ProjectRoutes] Error getting spec version:", error);
      return res.status(500).json({
        error: "Internal server error",
        message: error instanceof Error ? error.message : "Unknown error",
      });
    }
  },
);

// ============================================================================
// POST /project/:userSlug/:ideaSlug/spec/regenerate
// ============================================================================
// Regenerate spec from session

const RegenerateSpecSchema = z.object({
  sessionId: z.string().min(1, "sessionId is required"),
  blockReferences: z.array(z.string()).optional(),
  graphSnapshotId: z.string().optional(),
});

projectRouter.post(
  "/:userSlug/:ideaSlug/spec/regenerate",
  async (req: Request, res: Response) => {
    try {
      const { userSlug, ideaSlug } = req.params;

      if (!userSlug || !ideaSlug) {
        return res.status(400).json({
          error: "Validation error",
          message: "userSlug and ideaSlug are required",
        });
      }

      const parseResult = RegenerateSpecSchema.safeParse(req.body);
      if (!parseResult.success) {
        return res.status(400).json({
          error: "Validation error",
          details: parseResult.error.issues,
        });
      }

      const { sessionId, blockReferences, graphSnapshotId } = parseResult.data;

      console.log(
        `[ProjectRoutes] Regenerating spec for ${userSlug}/${ideaSlug} from session ${sessionId}`,
      );

      // Generate spec from session
      const result = await generateSpec(sessionId, userSlug);

      // Get sections for file output
      const sections = await getSpecSections(result.spec.id);

      // Save to file
      const specFilePath = await saveSpecToFile({
        userSlug,
        ideaSlug,
        spec: result.spec,
        sections,
        blockReferences,
        graphSnapshotId,
      });

      return res.json({
        success: true,
        data: {
          spec: result.spec,
          sections,
          confidence: result.confidence,
          sectionConfidences: result.sectionConfidences,
          needsReviewSections: result.needsReviewSections,
          clarifyingQuestions: result.clarifyingQuestions,
          filePath: specFilePath,
        },
      });
    } catch (error) {
      console.error("[ProjectRoutes] Error regenerating spec:", error);
      return res.status(500).json({
        error: "Internal server error",
        message: error instanceof Error ? error.message : "Unknown error",
      });
    }
  },
);

export default projectRouter;
