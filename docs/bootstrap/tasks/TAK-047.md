# TAK-047: Acceptance Criteria Generator Service

---

## Metadata

| Field | Value |
|-------|-------|
| **Phase** | Additional Capabilities |
| **Depends On** | TAK-011 |
| **Blocks** | None |
| **Priority** | P3 |
| **Owner** | Build Agent |

---

## Summary

Implement an AcceptanceGenerator service that auto-generates specific, measurable, and testable acceptance criteria from task descriptions.

---

## Requirements

1. **Description Analysis**:
   - Parse task description for key requirements
   - Extract implicit acceptance criteria
   - Identify measurable outcomes

2. **Criteria Generation**:
   - Generate specific, actionable criteria
   - Ensure criteria are testable
   - Avoid vague or subjective language

3. **Verification Methods**:
   - Suggest verification approach for each criterion
   - Link to test generation
   - Include manual verification steps

4. **Test Integration**:
   - Generate test scaffolds from criteria
   - Map criteria to test cases
   - Track coverage

---

## Pass Criteria

**PASS** when ALL of the following are true:

| # | Criterion | How to Verify |
|---|-----------|---------------|
| 1 | File exists | `test -f server/services/task-agent/acceptance-generator.ts` returns 0 |
| 2 | Has generate method | `grep -q "generate\|Generate" server/services/task-agent/acceptance-generator.ts` returns 0 |
| 3 | Has verification logic | `grep -q "verif\|Verif" server/services/task-agent/acceptance-generator.ts` returns 0 |
| 4 | Compiles | `npx tsc --noEmit server/services/task-agent/acceptance-generator.ts` passes |

**FAIL** if any criterion is not met.

---

## Output Files

```
server/services/task-agent/
└── acceptance-generator.ts
```

---

## Code Template

```typescript
// Acceptance Criteria Generator Service
// Auto-generates testable acceptance criteria from task descriptions

import type { Task, APITestCase, UITestCase } from '../../../types/task-agent';

interface AcceptanceCriterion {
  id: string;
  description: string;
  category: 'functional' | 'performance' | 'security' | 'ux' | 'data';
  testable: boolean;
  verificationMethod: 'api_test' | 'ui_test' | 'manual' | 'automated';
  suggestedTest?: Partial<APITestCase | UITestCase>;
}

interface GenerationResult {
  criteria: AcceptanceCriterion[];
  coverage: {
    functional: number;
    performance: number;
    security: number;
    ux: number;
    data: number;
  };
  suggestions: string[];
}

export class AcceptanceGenerator {
  // Patterns for extracting requirements
  private requirementPatterns = [
    { pattern: /user (?:can|should|must) (\w+)/gi, category: 'functional' as const },
    { pattern: /must be (?:able to )?(.*?)(?:\.|,|$)/gi, category: 'functional' as const },
    { pattern: /within (\d+)\s*(ms|seconds?|minutes?)/gi, category: 'performance' as const },
    { pattern: /secure|encrypt|auth|permission|access/gi, category: 'security' as const },
    { pattern: /display|show|render|visible|hidden/gi, category: 'ux' as const },
    { pattern: /store|save|persist|database|cache/gi, category: 'data' as const },
  ];

  // Common verbs that indicate testable actions
  private actionVerbs = [
    'create', 'read', 'update', 'delete', 'list', 'search', 'filter',
    'login', 'logout', 'register', 'submit', 'validate', 'upload',
    'download', 'export', 'import', 'send', 'receive', 'notify'
  ];

  async generateCriteria(task: Partial<Task>): Promise<GenerationResult> {
    const criteria: AcceptanceCriterion[] = [];
    const text = `${task.title || ''} ${task.description || ''}`;

    // Extract requirements from patterns
    for (const { pattern, category } of this.requirementPatterns) {
      const matches = text.matchAll(pattern);
      for (const match of matches) {
        const criterion = this.createCriterion(match[0], category);
        if (criterion) {
          criteria.push(criterion);
        }
      }
    }

    // Generate criteria based on task category
    const categoryCriteria = this.generateCategorySpecificCriteria(task);
    criteria.push(...categoryCriteria);

    // Extract action-based criteria
    const actionCriteria = this.extractActionCriteria(text);
    criteria.push(...actionCriteria);

    // Deduplicate
    const uniqueCriteria = this.deduplicateCriteria(criteria);

    // Calculate coverage
    const coverage = this.calculateCoverage(uniqueCriteria);

    // Generate suggestions for gaps
    const suggestions = this.generateSuggestions(coverage, task);

    return { criteria: uniqueCriteria, coverage, suggestions };
  }

  private createCriterion(
    text: string,
    category: AcceptanceCriterion['category']
  ): AcceptanceCriterion | null {
    // Clean and format the text
    const cleaned = text
      .replace(/^\s*[-*]\s*/, '')
      .replace(/\.$/, '')
      .trim();

    if (cleaned.length < 10) return null;

    const id = `ac-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`;

    // Determine verification method
    const verificationMethod = this.determineVerificationMethod(cleaned, category);

    const criterion: AcceptanceCriterion = {
      id,
      description: this.formatAsTestable(cleaned),
      category,
      testable: true,
      verificationMethod
    };

    // Add suggested test if applicable
    if (verificationMethod === 'api_test') {
      criterion.suggestedTest = this.suggestAPITest(cleaned);
    } else if (verificationMethod === 'ui_test') {
      criterion.suggestedTest = this.suggestUITest(cleaned);
    }

    return criterion;
  }

  private formatAsTestable(text: string): string {
    // Convert to testable format: "Given X, when Y, then Z"
    // Or simpler: "The system should X when Y"

    // If already in good format, return as-is
    if (/should|must|can/.test(text.toLowerCase())) {
      return text.charAt(0).toUpperCase() + text.slice(1);
    }

    // Otherwise, prefix with "The system should"
    return `The system should ${text.toLowerCase()}`;
  }

  private determineVerificationMethod(
    text: string,
    category: AcceptanceCriterion['category']
  ): AcceptanceCriterion['verificationMethod'] {
    const lowerText = text.toLowerCase();

    // UI-related keywords
    if (/display|show|visible|click|button|form|page|modal/.test(lowerText)) {
      return 'ui_test';
    }

    // API-related keywords
    if (/api|endpoint|request|response|return|create|update|delete/.test(lowerText)) {
      return 'api_test';
    }

    // Category-based defaults
    if (category === 'ux') return 'ui_test';
    if (category === 'performance') return 'automated';
    if (category === 'security') return 'automated';

    return 'manual';
  }

  private suggestAPITest(criterion: string): Partial<APITestCase> {
    const lowerCriterion = criterion.toLowerCase();

    // Detect CRUD operations
    if (/create|add|new/.test(lowerCriterion)) {
      return { method: 'POST', expectedStatus: 201 };
    }
    if (/update|modify|edit/.test(lowerCriterion)) {
      return { method: 'PUT', expectedStatus: 200 };
    }
    if (/delete|remove/.test(lowerCriterion)) {
      return { method: 'DELETE', expectedStatus: 200 };
    }
    if (/get|fetch|list|retrieve/.test(lowerCriterion)) {
      return { method: 'GET', expectedStatus: 200 };
    }

    return { method: 'GET', expectedStatus: 200 };
  }

  private suggestUITest(criterion: string): Partial<UITestCase> {
    return {
      captureScreenshots: true,
      screenshotOnFailure: true,
      viewport: { width: 1280, height: 720 }
    };
  }

  private generateCategorySpecificCriteria(task: Partial<Task>): AcceptanceCriterion[] {
    const criteria: AcceptanceCriterion[] = [];
    const category = task.category || 'feature';

    // Add standard criteria based on task category
    const categoryDefaults: Record<string, AcceptanceCriterion[]> = {
      feature: [
        {
          id: `ac-${Date.now()}-def1`,
          description: 'Feature is accessible from the main navigation',
          category: 'ux',
          testable: true,
          verificationMethod: 'ui_test'
        },
        {
          id: `ac-${Date.now()}-def2`,
          description: 'Error states are handled gracefully with user feedback',
          category: 'ux',
          testable: true,
          verificationMethod: 'ui_test'
        }
      ],
      bug: [
        {
          id: `ac-${Date.now()}-bug1`,
          description: 'The reported issue no longer occurs',
          category: 'functional',
          testable: true,
          verificationMethod: 'manual'
        },
        {
          id: `ac-${Date.now()}-bug2`,
          description: 'Regression test added to prevent recurrence',
          category: 'functional',
          testable: true,
          verificationMethod: 'automated'
        }
      ],
      security: [
        {
          id: `ac-${Date.now()}-sec1`,
          description: 'Input is validated and sanitized',
          category: 'security',
          testable: true,
          verificationMethod: 'automated'
        },
        {
          id: `ac-${Date.now()}-sec2`,
          description: 'Authentication is required for protected resources',
          category: 'security',
          testable: true,
          verificationMethod: 'api_test'
        }
      ]
    };

    return categoryDefaults[category] || [];
  }

  private extractActionCriteria(text: string): AcceptanceCriterion[] {
    const criteria: AcceptanceCriterion[] = [];

    for (const verb of this.actionVerbs) {
      const pattern = new RegExp(`${verb}\\s+(?:a |the |an )?([\\w\\s]+?)(?:\\.|,|$)`, 'gi');
      const matches = text.matchAll(pattern);

      for (const match of matches) {
        const object = match[1].trim();
        if (object.length > 3 && object.length < 50) {
          criteria.push({
            id: `ac-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`,
            description: `User can ${verb} ${object}`,
            category: 'functional',
            testable: true,
            verificationMethod: 'api_test'
          });
        }
      }
    }

    return criteria;
  }

  private deduplicateCriteria(criteria: AcceptanceCriterion[]): AcceptanceCriterion[] {
    const seen = new Set<string>();
    return criteria.filter(c => {
      const key = c.description.toLowerCase();
      if (seen.has(key)) return false;
      seen.add(key);
      return true;
    });
  }

  private calculateCoverage(criteria: AcceptanceCriterion[]): GenerationResult['coverage'] {
    const counts = { functional: 0, performance: 0, security: 0, ux: 0, data: 0 };

    for (const c of criteria) {
      counts[c.category]++;
    }

    const total = criteria.length || 1;
    return {
      functional: counts.functional / total,
      performance: counts.performance / total,
      security: counts.security / total,
      ux: counts.ux / total,
      data: counts.data / total
    };
  }

  private generateSuggestions(
    coverage: GenerationResult['coverage'],
    task: Partial<Task>
  ): string[] {
    const suggestions: string[] = [];

    if (coverage.security === 0 && task.category !== 'documentation') {
      suggestions.push('Consider adding security-related acceptance criteria');
    }

    if (coverage.performance === 0 && ['feature', 'performance'].includes(task.category || '')) {
      suggestions.push('Consider adding performance requirements (response times, limits)');
    }

    if (coverage.ux === 0 && ['feature', 'improvement', 'ux_design'].includes(task.category || '')) {
      suggestions.push('Consider adding UX/accessibility acceptance criteria');
    }

    return suggestions;
  }
}

export default AcceptanceGenerator;
```

---

## Gotchas

- Generated criteria need human review
- Context from project domain improves quality
- Don't generate too many criteria (keep focused)

---

## Validation

```bash
# Type check
npx tsc --noEmit server/services/task-agent/acceptance-generator.ts

# Run unit tests
npm test -- --grep "acceptance-generator"
```

---

## Next Steps

After completing this task:
1. Integrate with TaskCreateForm
2. Add to validation gate suggestions
3. Connect to TestGenerator for test scaffolding
