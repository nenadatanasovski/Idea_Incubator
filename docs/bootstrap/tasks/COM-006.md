# COM-006: Question Delivery with Inline Buttons

---

## Metadata

| Field          | Value                  |
| -------------- | ---------------------- |
| **Phase**      | 0 - Communication Core |
| **Depends On** | COM-004, QUE-001       |
| **Blocks**     | COM-007, COM-010       |
| **Priority**   | P1                     |
| **Owner**      | Build Agent            |

---

## Summary

Implement the question delivery system that formats questions according to their type and sends them via Telegram with appropriate inline buttons.

---

## Requirements

1. **Message Templates**:
   - Different formats per question type
   - Configurable verbosity (concise/standard/detailed)
   - Markdown formatting for readability

2. **Button Generation**:
   - Convert question options to inline buttons
   - Always include "Other" option for free-text
   - Callback data format: `answer:{questionId}:{action}`

3. **Question Type Handling**:
   - ALERT: No buttons (informational only)
   - BLOCKING/CLARIFYING/etc: Options as buttons
   - APPROVAL: Yes/No + alternative options
   - EMERGENCY: Prominent formatting, urgent styling

4. **Delivery Tracking**:
   - Track which questions sent to Telegram
   - Store message ID for updates/edits
   - Record delivery timestamp

---

## Pass Criteria

**PASS** when ALL of the following are true:

| #   | Criterion                  | How to Verify                                                                                    |
| --- | -------------------------- | ------------------------------------------------------------------------------------------------ |
| 1   | File exists                | `test -f server/communication/question-delivery.ts` returns 0                                    |
| 2   | Exports QuestionDelivery   | `grep -q "export class QuestionDelivery" server/communication/question-delivery.ts` returns 0    |
| 3   | Has deliverQuestion method | `grep -q "deliverQuestion\|deliver(" server/communication/question-delivery.ts` returns 0        |
| 4   | Has message templates      | `grep -q "template\|formatMessage" server/communication/question-delivery.ts` returns 0          |
| 5   | Handles all question types | `grep -c "ALERT\|BLOCKING\|APPROVAL\|ESCALATION" server/communication/question-delivery.ts` >= 4 |
| 6   | TypeScript compiles        | `npx tsc --noEmit server/communication/question-delivery.ts` returns 0                           |
| 7   | Unit tests pass            | `npm test -- --grep "question-delivery"` passes                                                  |

**FAIL** if any criterion is not met.

---

## Output Files

```
server/communication/
‚îî‚îÄ‚îÄ question-delivery.ts
```

---

## Code Template

```typescript
// server/communication/question-delivery.ts

import { TelegramSender } from "./telegram-sender";
import { AgentType } from "./bot-registry";

type QuestionType =
  | "BLOCKING"
  | "CLARIFYING"
  | "CONFIRMING"
  | "PREFERENCE"
  | "ALERT"
  | "ESCALATION"
  | "APPROVAL"
  | "DECISION";

type MessageFormat = "concise" | "standard" | "detailed" | "urgent";

interface Question {
  id: string;
  agentId: string;
  type: QuestionType;
  content: string;
  context?: any;
  options: { label: string; action: string; description?: string }[];
  defaultOption?: string;
  priority: number;
  blocking: boolean;
}

interface DeliveryResult {
  success: boolean;
  messageId?: number;
  channel: "telegram";
  deliveredAt: Date;
  error?: string;
}

const FORMAT_CONFIG: Record<QuestionType, MessageFormat> = {
  ALERT: "concise",
  CLARIFYING: "concise",
  CONFIRMING: "standard",
  PREFERENCE: "standard",
  BLOCKING: "standard",
  DECISION: "detailed",
  ESCALATION: "detailed",
  APPROVAL: "detailed",
};

const TYPE_EMOJI: Record<QuestionType, string> = {
  ALERT: "‚ÑπÔ∏è",
  CLARIFYING: "‚ùì",
  CONFIRMING: "‚úÖ",
  PREFERENCE: "üéØ",
  BLOCKING: "üî¥",
  DECISION: "ü§î",
  ESCALATION: "‚ö†Ô∏è",
  APPROVAL: "üö®",
};

export class QuestionDelivery {
  private sender: TelegramSender;
  private deliveryLog: Map<string, DeliveryResult> = new Map();

  constructor(sender: TelegramSender) {
    this.sender = sender;
  }

  async deliverQuestion(question: Question): Promise<DeliveryResult> {
    const agentType = this.extractAgentType(question.agentId);
    const format = FORMAT_CONFIG[question.type];
    const message = this.formatMessage(question, format);
    const buttons = this.generateButtons(question);

    let result: DeliveryResult;

    if (question.type === "ALERT") {
      // Alerts don't need buttons
      const sendResult = await this.sender.sendMessage({
        agentType,
        text: message,
        parseMode: "Markdown",
      });

      result = {
        success: sendResult.success,
        messageId: sendResult.messageId,
        channel: "telegram",
        deliveredAt: new Date(),
        error: sendResult.error,
      };
    } else {
      const sendResult = await this.sender.sendWithButtons(
        agentType,
        message,
        buttons,
      );

      result = {
        success: sendResult.success,
        messageId: sendResult.messageId,
        channel: "telegram",
        deliveredAt: new Date(),
        error: sendResult.error,
      };
    }

    this.deliveryLog.set(question.id, result);
    return result;
  }

  getDeliveryStatus(questionId: string): DeliveryResult | null {
    return this.deliveryLog.get(questionId) || null;
  }

  private formatMessage(question: Question, format: MessageFormat): string {
    const emoji = TYPE_EMOJI[question.type];
    const typeLabel = this.getTypeLabel(question.type);

    switch (format) {
      case "concise":
        return this.formatConcise(question, emoji, typeLabel);
      case "standard":
        return this.formatStandard(question, emoji, typeLabel);
      case "detailed":
        return this.formatDetailed(question, emoji, typeLabel);
      case "urgent":
        return this.formatUrgent(question, emoji, typeLabel);
      default:
        return this.formatStandard(question, emoji, typeLabel);
    }
  }

  private formatConcise(q: Question, emoji: string, typeLabel: string): string {
    return `${emoji} *${typeLabel}*\n\n${q.content}`;
  }

  private formatStandard(
    q: Question,
    emoji: string,
    typeLabel: string,
  ): string {
    let msg = `${emoji} *${typeLabel}*\n\n${q.content}`;

    if (q.options.length > 0) {
      msg += "\n\n*Options:*";
      for (const opt of q.options) {
        msg += `\n‚Ä¢ ${opt.label}`;
        if (opt.description) {
          msg += ` - _${opt.description}_`;
        }
      }
    }

    if (q.blocking) {
      msg += `\n\n_Agent blocked: \`${q.agentId}\`_`;
    }

    return msg;
  }

  private formatDetailed(
    q: Question,
    emoji: string,
    typeLabel: string,
  ): string {
    let msg = `${emoji} *${typeLabel}*\n\n${q.content}`;

    if (q.options.length > 0) {
      msg += "\n\n*Options:*";
      for (const opt of q.options) {
        msg += `\n\n*${opt.label}*`;
        if (opt.description) {
          msg += `\n${opt.description}`;
        }
      }
    }

    if (q.context) {
      msg += "\n\n*Context:*";
      if (q.context.rationale) {
        msg += `\n_${q.context.rationale}_`;
      }
      if (q.context.evidence) {
        msg += `\n\`\`\`\n${JSON.stringify(q.context.evidence, null, 2).slice(0, 500)}\n\`\`\``;
      }
    }

    if (q.blocking) {
      msg += `\n\n‚è∏Ô∏è _Agent blocked: \`${q.agentId}\`_`;
    }

    if (q.defaultOption) {
      msg += `\n\nüí° _Default (on timeout): ${q.defaultOption}_`;
    }

    return msg;
  }

  private formatUrgent(q: Question, emoji: string, typeLabel: string): string {
    return `üö®üö®üö®\n\n${this.formatDetailed(q, emoji, typeLabel)}\n\nüö®üö®üö®`;
  }

  private generateButtons(
    question: Question,
  ): { text: string; callbackData: string }[][] {
    if (question.type === "ALERT") {
      return []; // No buttons for alerts
    }

    const buttons: { text: string; callbackData: string }[][] = [];

    // Main options (2 per row for readability)
    for (let i = 0; i < question.options.length; i += 2) {
      const row = [];
      row.push({
        text: question.options[i].label,
        callbackData: `answer:${question.id}:${question.options[i].action}`,
      });

      if (question.options[i + 1]) {
        row.push({
          text: question.options[i + 1].label,
          callbackData: `answer:${question.id}:${question.options[i + 1].action}`,
        });
      }

      buttons.push(row);
    }

    // Add "Other" option
    buttons.push([
      {
        text: "üí¨ Other (type reply)",
        callbackData: `answer:${question.id}:other`,
      },
    ]);

    return buttons;
  }

  private getTypeLabel(type: QuestionType): string {
    const labels: Record<QuestionType, string> = {
      ALERT: "Alert",
      CLARIFYING: "Clarifying Question",
      CONFIRMING: "Confirmation Needed",
      PREFERENCE: "Your Preference?",
      BLOCKING: "Blocking Question",
      DECISION: "Decision Required",
      ESCALATION: "Escalation",
      APPROVAL: "Approval Required",
    };
    return labels[type];
  }

  private extractAgentType(agentId: string): AgentType {
    if (agentId.includes("monitor")) return "monitoring";
    if (agentId.includes("orchestrat")) return "orchestrator";
    if (agentId.includes("spec")) return "spec";
    if (agentId.includes("build")) return "build";
    if (agentId.includes("valid")) return "validation";
    if (agentId.includes("sia")) return "sia";
    return "system";
  }
}
```

---

## Example Messages

### ALERT (concise)

```
‚ÑπÔ∏è *Alert*

Agent `spec-agent-123` has been idle for 5 minutes.
No action required.
```

### BLOCKING (standard)

```
üî¥ *Blocking Question*

Which authentication approach should I use?

*Options:*
‚Ä¢ JWT Tokens - _Stateless, scales easily_
‚Ä¢ Server Sessions - _Easy invalidation_

_Agent blocked: `spec-agent-123`_

[JWT Tokens] [Server Sessions]
[üí¨ Other (type reply)]
```

### APPROVAL (detailed)

```
üö® *Approval Required*

I want to *KILL* agent `build-agent-456`.

*Options:*

*Yes, kill it*
Agent will be terminated and require manual restart.

*No, let it retry*
Agent will continue with exponential backoff.

*Pause instead*
Agent will pause, can be resumed later.

*Context:*
_Agent has failed 5 consecutive tasks with same error._

```

TypeError: Cannot read property 'id' of undefined

```

‚è∏Ô∏è _Agent blocked: `build-agent-456`_
üí° _Default (on timeout): Pause instead_

[Yes, kill it] [No, let it retry]
[Pause instead]
[üí¨ Other (type reply)]
```

---

## Validation

```bash
npx tsc --noEmit server/communication/question-delivery.ts
npm test -- --grep "question-delivery"
```
