# COM-010: Notification Dispatcher (Routing & Fallback)

---

## Metadata

| Field | Value |
|-------|-------|
| **Phase** | 0 - Communication Core |
| **Depends On** | COM-006, COM-009 |
| **Blocks** | COM-011 |
| **Priority** | P1 |
| **Owner** | Build Agent |

---

## Summary

Implement the notification dispatcher that routes questions and alerts through the fallback chain (Telegram → Email → Halt) based on delivery success and question type.

---

## Context

### Fallback Chain

```
┌─────────────┐    fail    ┌─────────────┐    fail    ┌─────────────┐
│  TELEGRAM   │ ─────────▶ │   EMAIL     │ ─────────▶ │  FALLBACK   │
│  (primary)  │            │  (backup)   │            │  BEHAVIOR   │
└─────────────┘            └─────────────┘            └─────────────┘
                                                             │
                    ┌────────────────────────────────────────┘
                    │
                    ▼
       ┌─────────────────────────────────────────────┐
       │  Based on Question Type:                    │
       │                                             │
       │  APPROVAL/EMERGENCY → HARD HALT             │
       │  ESCALATION         → HALT + hourly retry   │
       │  DECISION           → Timeout (30 min)      │
       │  BLOCKING           → Timeout (configurable)│
       │  CLARIFYING         → Timeout (5 min)       │
       │  ALERT              → Log only              │
       └─────────────────────────────────────────────┘
```

---

## Requirements

1. **Routing Logic**:
   - Try Telegram first (all questions)
   - On failure, try Email
   - On both failure, apply fallback behavior

2. **Fallback Behaviors**:
   - HARD_HALT: Block indefinitely, retry notifications hourly
   - TIMEOUT: Wait for configured duration, then use default
   - LOG_ONLY: Just log, don't block

3. **Delivery Tracking**:
   - Track which channel(s) succeeded
   - Record all delivery attempts
   - Calculate delivery latency

4. **Retry Logic**:
   - For HARD_HALT questions, retry notification every hour
   - Stop retrying once answered
   - Log all retry attempts

---

## Pass Criteria

**PASS** when ALL of the following are true:

| # | Criterion | How to Verify |
|---|-----------|---------------|
| 1 | File exists | `test -f server/communication/notification-dispatcher.ts` returns 0 |
| 2 | Exports NotificationDispatcher | `grep -q "export class NotificationDispatcher" server/communication/notification-dispatcher.ts` returns 0 |
| 3 | Has dispatch method | `grep -q "dispatch(" server/communication/notification-dispatcher.ts` returns 0 |
| 4 | Has fallback chain | `grep -q "fallback\|TELEGRAM.*EMAIL\|chain" server/communication/notification-dispatcher.ts` returns 0 |
| 5 | Has HARD_HALT behavior | `grep -q "HARD_HALT\|hardHalt" server/communication/notification-dispatcher.ts` returns 0 |
| 6 | TypeScript compiles | `npx tsc --noEmit server/communication/notification-dispatcher.ts` returns 0 |
| 7 | Unit tests pass | `npm test -- --grep "notification-dispatcher"` passes |

**FAIL** if any criterion is not met.

---

## Output Files

```
server/communication/
└── notification-dispatcher.ts
```

---

## Code Template

```typescript
// server/communication/notification-dispatcher.ts

import { EventEmitter } from 'events';
import { QuestionDelivery } from './question-delivery';
import { EmailQuestionDelivery } from './email-question-delivery';

type QuestionType =
  | 'BLOCKING' | 'CLARIFYING' | 'CONFIRMING' | 'PREFERENCE'
  | 'ALERT' | 'ESCALATION' | 'APPROVAL' | 'DECISION';

type FallbackBehavior = 'HARD_HALT' | 'TIMEOUT' | 'LOG_ONLY';

interface Question {
  id: string;
  agentId: string;
  type: QuestionType;
  content: string;
  options: { label: string; action: string }[];
  defaultOption?: string;
  priority: number;
  blocking: boolean;
  timeout?: number;
  timeoutAction?: string;
}

interface DispatchResult {
  questionId: string;
  delivered: boolean;
  channels: ('telegram' | 'email')[];
  fallbackBehavior?: FallbackBehavior;
  error?: string;
}

interface TypeConfig {
  fallbackBehavior: FallbackBehavior;
  defaultTimeout: number | null;  // null = no timeout
  defaultAction: string | null;
  retryInterval: number;  // ms between retry notifications
}

const TYPE_CONFIGS: Record<QuestionType, TypeConfig> = {
  APPROVAL: {
    fallbackBehavior: 'HARD_HALT',
    defaultTimeout: null,
    defaultAction: null,
    retryInterval: 3600_000,  // 1 hour
  },
  EMERGENCY: {
    fallbackBehavior: 'HARD_HALT',
    defaultTimeout: null,
    defaultAction: null,
    retryInterval: 1800_000,  // 30 min
  },
  ESCALATION: {
    fallbackBehavior: 'HARD_HALT',
    defaultTimeout: 3600_000,  // 1 hour
    defaultAction: 'pause',
    retryInterval: 3600_000,
  },
  DECISION: {
    fallbackBehavior: 'TIMEOUT',
    defaultTimeout: 1800_000,  // 30 min
    defaultAction: 'wait',
    retryInterval: 0,
  },
  BLOCKING: {
    fallbackBehavior: 'TIMEOUT',
    defaultTimeout: 900_000,  // 15 min
    defaultAction: 'use_default',
    retryInterval: 0,
  },
  CLARIFYING: {
    fallbackBehavior: 'TIMEOUT',
    defaultTimeout: 300_000,  // 5 min
    defaultAction: 'use_default',
    retryInterval: 0,
  },
  CONFIRMING: {
    fallbackBehavior: 'TIMEOUT',
    defaultTimeout: 600_000,  // 10 min
    defaultAction: 'proceed',
    retryInterval: 0,
  },
  PREFERENCE: {
    fallbackBehavior: 'TIMEOUT',
    defaultTimeout: 300_000,  // 5 min
    defaultAction: 'use_default',
    retryInterval: 0,
  },
  ALERT: {
    fallbackBehavior: 'LOG_ONLY',
    defaultTimeout: null,
    defaultAction: null,
    retryInterval: 0,
  },
};

export class NotificationDispatcher extends EventEmitter {
  private telegramDelivery: QuestionDelivery;
  private emailDelivery: EmailQuestionDelivery;
  private retryTimers: Map<string, ReturnType<typeof setInterval>> = new Map();
  private deliveryLog: Map<string, DispatchResult> = new Map();

  constructor(
    telegramDelivery: QuestionDelivery,
    emailDelivery: EmailQuestionDelivery
  ) {
    super();
    this.telegramDelivery = telegramDelivery;
    this.emailDelivery = emailDelivery;
  }

  async dispatch(question: Question): Promise<DispatchResult> {
    const config = TYPE_CONFIGS[question.type];
    const channels: ('telegram' | 'email')[] = [];
    let delivered = false;

    // Step 1: Try Telegram
    const telegramResult = await this.telegramDelivery.deliverQuestion(question as any);

    if (telegramResult.success) {
      channels.push('telegram');
      delivered = true;
    } else {
      console.warn(`Telegram delivery failed for ${question.id}: ${telegramResult.error}`);

      // Step 2: Try Email
      const emailResult = await this.emailDelivery.deliverQuestion(question);

      if (emailResult.success) {
        channels.push('email');
        delivered = true;
      } else {
        console.error(`Email delivery also failed for ${question.id}: ${emailResult.error}`);
      }
    }

    const result: DispatchResult = {
      questionId: question.id,
      delivered,
      channels,
      fallbackBehavior: delivered ? undefined : config.fallbackBehavior,
    };

    this.deliveryLog.set(question.id, result);

    // Step 3: Handle delivery failure
    if (!delivered) {
      await this.handleDeliveryFailure(question, config);
    }

    // Step 4: Set up timeout if applicable
    if (delivered && config.defaultTimeout) {
      this.setupTimeout(question, config);
    }

    return result;
  }

  cancelRetries(questionId: string): void {
    const timer = this.retryTimers.get(questionId);
    if (timer) {
      clearInterval(timer);
      this.retryTimers.delete(questionId);
    }
  }

  getDeliveryStatus(questionId: string): DispatchResult | null {
    return this.deliveryLog.get(questionId) || null;
  }

  private async handleDeliveryFailure(question: Question, config: TypeConfig): Promise<void> {
    switch (config.fallbackBehavior) {
      case 'HARD_HALT':
        console.error(`HARD HALT: Question ${question.id} could not be delivered. Agent will block.`);
        this.emit('delivery:hardHalt', { questionId: question.id, question });

        // Set up retry notifications
        if (config.retryInterval > 0) {
          this.setupRetryNotifications(question, config.retryInterval);
        }
        break;

      case 'TIMEOUT':
        console.warn(`Delivery failed for ${question.id}. Will timeout to default.`);
        // Timeout handling is done elsewhere (question queue)
        break;

      case 'LOG_ONLY':
        console.log(`Alert ${question.id} could not be delivered. Logged only.`);
        break;
    }
  }

  private setupRetryNotifications(question: Question, interval: number): void {
    const timer = setInterval(async () => {
      console.log(`Retrying notification for ${question.id}...`);

      // Try Telegram again
      const telegramResult = await this.telegramDelivery.deliverQuestion(question as any);

      if (telegramResult.success) {
        console.log(`Retry succeeded for ${question.id} via Telegram`);
        this.cancelRetries(question.id);
        return;
      }

      // Try Email again
      const emailResult = await this.emailDelivery.deliverQuestion(question);

      if (emailResult.success) {
        console.log(`Retry succeeded for ${question.id} via Email`);
        this.cancelRetries(question.id);
        return;
      }

      console.error(`Retry failed for ${question.id}. Will try again in ${interval / 60000} minutes.`);
    }, interval);

    this.retryTimers.set(question.id, timer);
  }

  private setupTimeout(question: Question, config: TypeConfig): void {
    const timeout = question.timeout || config.defaultTimeout;
    if (!timeout) return;

    setTimeout(() => {
      // Check if still pending
      this.emit('timeout:check', {
        questionId: question.id,
        defaultAction: question.timeoutAction || config.defaultAction,
      });
    }, timeout);
  }
}
```

---

## Events

```typescript
// Hard halt event - agent should block
dispatcher.on('delivery:hardHalt', ({ questionId, question }) => {
  // Pause agent until question answered
});

// Timeout check - question queue handles this
dispatcher.on('timeout:check', ({ questionId, defaultAction }) => {
  // If question still pending, apply default action
});
```

---

## Validation

```bash
npx tsc --noEmit server/communication/notification-dispatcher.ts
npm test -- --grep "notification-dispatcher"
```
