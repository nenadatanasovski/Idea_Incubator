# COM-009: Email Question Delivery (Fallback)

---

## Metadata

| Field | Value |
|-------|-------|
| **Phase** | 0 - Communication Core |
| **Depends On** | COM-008, QUE-001 |
| **Blocks** | COM-010 |
| **Priority** | P1 |
| **Owner** | Build Agent |

---

## Summary

Implement question delivery via email as fallback when Telegram fails. Email answers are processed via reply parsing.

---

## Requirements

1. **Question Delivery**:
   - Format questions for email (plain text + HTML)
   - Include question ID in subject for threading
   - Numbered options for easy reply

2. **Reply Processing**:
   - Poll inbox for replies (IMAP)
   - Parse reply for answer (number or text)
   - Match to question by subject/ID
   - Handle multi-line replies

3. **Fallback Trigger**:
   - Called when Telegram delivery fails
   - Extended timeout for email (slower medium)
   - Track delivery status

---

## Pass Criteria

**PASS** when ALL of the following are true:

| # | Criterion | How to Verify |
|---|-----------|---------------|
| 1 | File exists | `test -f server/communication/email-question-delivery.ts` returns 0 |
| 2 | Exports EmailQuestionDelivery | `grep -q "export class EmailQuestionDelivery" server/communication/email-question-delivery.ts` returns 0 |
| 3 | Has deliverQuestion method | `grep -q "deliverQuestion" server/communication/email-question-delivery.ts` returns 0 |
| 4 | Has reply parsing | `grep -q "parseReply\|processReply" server/communication/email-question-delivery.ts` returns 0 |
| 5 | TypeScript compiles | `npx tsc --noEmit server/communication/email-question-delivery.ts` returns 0 |
| 6 | Unit tests pass | `npm test -- --grep "email-question-delivery"` passes |

**FAIL** if any criterion is not met.

---

## Output Files

```
server/communication/
└── email-question-delivery.ts
```

---

## Code Template

```typescript
// server/communication/email-question-delivery.ts

import { EventEmitter } from 'events';
import { EmailSender } from './email-sender';
import Imap from 'imap';
import { simpleParser } from 'mailparser';

interface Question {
  id: string;
  agentId: string;
  type: string;
  content: string;
  options: { label: string; action: string }[];
}

interface DeliveryResult {
  success: boolean;
  messageId?: string;
  error?: string;
}

export class EmailQuestionDelivery extends EventEmitter {
  private emailSender: EmailSender;
  private primaryEmail: string;
  private imap: Imap | null = null;
  private pendingQuestions: Map<string, Question> = new Map();
  private polling: boolean = false;

  constructor(emailSender: EmailSender, primaryEmail: string) {
    super();
    this.emailSender = emailSender;
    this.primaryEmail = primaryEmail;
  }

  async deliverQuestion(question: Question): Promise<DeliveryResult> {
    const result = await this.emailSender.sendQuestion(
      this.primaryEmail,
      question.id,
      this.formatQuestionContent(question),
      question.options
    );

    if (result.success) {
      this.pendingQuestions.set(question.id, question);
    }

    return {
      success: result.success,
      messageId: result.messageId,
      error: result.error,
    };
  }

  async startReplyPolling(config: {
    host: string;
    port: number;
    user: string;
    password: string;
  }): Promise<void> {
    if (this.polling) return;

    this.imap = new Imap({
      user: config.user,
      password: config.password,
      host: config.host,
      port: config.port,
      tls: true,
    });

    this.imap.once('ready', () => {
      this.polling = true;
      this.pollForReplies();
    });

    this.imap.once('error', (err) => {
      console.error('IMAP error:', err);
    });

    this.imap.connect();
  }

  stopReplyPolling(): void {
    this.polling = false;
    if (this.imap) {
      this.imap.end();
      this.imap = null;
    }
  }

  private async pollForReplies(): Promise<void> {
    if (!this.polling || !this.imap) return;

    try {
      await this.checkInbox();
    } catch (error) {
      console.error('Error checking inbox:', error);
    }

    // Poll every 30 seconds
    setTimeout(() => this.pollForReplies(), 30000);
  }

  private async checkInbox(): Promise<void> {
    return new Promise((resolve, reject) => {
      this.imap!.openBox('INBOX', false, (err, box) => {
        if (err) return reject(err);

        // Search for unread replies to Vibe questions
        this.imap!.search(['UNSEEN', ['SUBJECT', '[Vibe]']], (err, results) => {
          if (err) return reject(err);

          if (results.length === 0) {
            return resolve();
          }

          const f = this.imap!.fetch(results, { bodies: '' });

          f.on('message', (msg) => {
            msg.on('body', (stream) => {
              simpleParser(stream as any, async (err, mail) => {
                if (err) return;
                await this.processReply(mail);
              });
            });
          });

          f.once('error', reject);
          f.once('end', resolve);
        });
      });
    });
  }

  private async processReply(mail: any): Promise<void> {
    // Extract question ID from subject
    const subject = mail.subject || '';
    const questionIdMatch = subject.match(/Question ID: ([a-zA-Z0-9-]+)/);

    if (!questionIdMatch) {
      // Try to find in body
      const body = mail.text || '';
      const bodyMatch = body.match(/Question ID: ([a-zA-Z0-9-]+)/);
      if (!bodyMatch) return;
    }

    const questionId = questionIdMatch ? questionIdMatch[1] : '';
    const question = this.pendingQuestions.get(questionId);

    if (!question) {
      console.warn(`Reply for unknown question: ${questionId}`);
      return;
    }

    // Parse the reply
    const replyText = this.extractReplyText(mail.text || '');
    const answer = this.parseAnswer(replyText, question.options);

    // Emit answer event
    this.emit('answer:received', {
      questionId,
      answer: {
        questionId,
        action: answer.action,
        freeText: answer.freeText,
        answeredBy: 'user',
        answeredAt: new Date(),
        channel: 'email',
      },
    });

    // Remove from pending
    this.pendingQuestions.delete(questionId);

    // Mark email as read
    // this.imap.addFlags(mail.uid, '\\Seen', () => {});
  }

  private extractReplyText(fullText: string): string {
    // Remove quoted text (lines starting with >)
    const lines = fullText.split('\n');
    const replyLines: string[] = [];

    for (const line of lines) {
      if (line.startsWith('>')) break; // Stop at quoted text
      if (line.includes('wrote:')) break; // Stop at attribution
      if (line.includes('On ') && line.includes(' at ')) break; // Stop at date line
      replyLines.push(line);
    }

    return replyLines.join('\n').trim();
  }

  private parseAnswer(
    replyText: string,
    options: { label: string; action: string }[]
  ): { action: string; freeText?: string } {
    const text = replyText.trim();

    // Check for number (1, 2, 3...)
    const numberMatch = text.match(/^(\d+)/);
    if (numberMatch) {
      const index = parseInt(numberMatch[1]) - 1;
      if (index >= 0 && index < options.length) {
        return { action: options[index].action };
      }
    }

    // Check for option label match
    const lowerText = text.toLowerCase();
    for (const opt of options) {
      if (lowerText.includes(opt.label.toLowerCase())) {
        return { action: opt.action };
      }
    }

    // Treat as free-text "other" response
    return { action: 'other', freeText: text };
  }

  private formatQuestionContent(question: Question): string {
    let content = question.content;

    // Add context about agent
    content += `\n\n(From: ${question.agentId})`;

    return content;
  }
}
```

---

## Environment Variables

```bash
# .env (add IMAP settings for reply reading)
IMAP_HOST=imap.gmail.com
IMAP_PORT=993
IMAP_USER=ned.python@gmail.com
IMAP_PASS=xxxx-xxxx-xxxx-xxxx  # Same app password as SMTP
```

---

## Validation

```bash
npm install imap mailparser
npm install --save-dev @types/imap

npx tsc --noEmit server/communication/email-question-delivery.ts
npm test -- --grep "email-question-delivery"
```
