# COM-005: Telegram Multi-Bot Receiver (Long Polling)

---

## Metadata

| Field | Value |
|-------|-------|
| **Phase** | 0 - Communication Core |
| **Depends On** | COM-002, COM-003 |
| **Blocks** | COM-007 |
| **Priority** | P1 |
| **Owner** | Build Agent |

---

## Summary

Implement the Telegram receiver that listens for incoming messages and callback queries across all bots using long polling.

---

## Context

### Why Long Polling (Not Webhooks)?

| Approach | Pros | Cons |
|----------|------|------|
| **Long Polling** | No public URL needed, simpler setup, works locally | Slightly higher latency, multiple connections |
| **Webhooks** | Lower latency, single endpoint | Needs HTTPS, public URL, SSL cert |

For a local/dev-first system, long polling is simpler and works everywhere.

### Multi-Bot Polling

Each bot needs its own polling loop. We run 7 parallel polling loops, one per bot.

---

## Requirements

1. **Multi-Bot Polling**:
   - Start polling loop for each registered bot
   - Handle updates independently
   - Graceful shutdown (drain all loops)

2. **Update Types**:
   - `/start` command → trigger chat linking
   - `/summary` command → request summary from Monitoring Agent
   - Text messages → potential verification code or free-text answer
   - Callback queries → button presses (answers)

3. **Event Emission**:
   - Emit events for handlers to process
   - Include bot type in event payload
   - Track message IDs for threading

---

## Pass Criteria

**PASS** when ALL of the following are true:

| # | Criterion | How to Verify |
|---|-----------|---------------|
| 1 | File exists | `test -f server/communication/telegram-receiver.ts` returns 0 |
| 2 | Exports TelegramReceiver | `grep -q "export class TelegramReceiver" server/communication/telegram-receiver.ts` returns 0 |
| 3 | Has startPolling method | `grep -q "startPolling\|start(" server/communication/telegram-receiver.ts` returns 0 |
| 4 | Handles callbacks | `grep -q "callback_query\|CallbackQuery" server/communication/telegram-receiver.ts` returns 0 |
| 5 | Multi-bot support | `grep -q "for.*bot\|bots.forEach\|Promise.all" server/communication/telegram-receiver.ts` returns 0 |
| 6 | TypeScript compiles | `npx tsc --noEmit server/communication/telegram-receiver.ts` returns 0 |
| 7 | Unit tests pass | `npm test -- --grep "telegram-receiver"` passes |

**FAIL** if any criterion is not met.

---

## Output Files

```
server/communication/
└── telegram-receiver.ts
```

---

## Code Template

```typescript
// server/communication/telegram-receiver.ts

import { EventEmitter } from 'events';
import { BotRegistry, RegisteredBot, AgentType } from './bot-registry';

interface TelegramUpdate {
  update_id: number;
  message?: TelegramMessage;
  callback_query?: TelegramCallbackQuery;
}

interface TelegramMessage {
  message_id: number;
  from: { id: number; username?: string };
  chat: { id: number };
  text?: string;
  date: number;
}

interface TelegramCallbackQuery {
  id: string;
  from: { id: number; username?: string };
  message?: TelegramMessage;
  data?: string;
}

export interface ReceivedMessage {
  botType: AgentType;
  chatId: string;
  messageId: number;
  text: string;
  fromUserId: number;
  fromUsername?: string;
  timestamp: Date;
}

export interface ReceivedCallback {
  botType: AgentType;
  callbackId: string;
  chatId: string;
  messageId: number;
  data: string;
  fromUserId: number;
}

export class TelegramReceiver extends EventEmitter {
  private botRegistry: BotRegistry;
  private running: boolean = false;
  private offsets: Map<AgentType, number> = new Map();
  private pollingIntervals: Map<AgentType, ReturnType<typeof setTimeout>> = new Map();

  constructor(botRegistry: BotRegistry) {
    super();
    this.botRegistry = botRegistry;
  }

  async start(): Promise<void> {
    this.running = true;
    const bots = this.botRegistry.getAllBots();

    // Start polling loop for each bot
    for (const bot of bots) {
      this.startBotPolling(bot);
    }

    console.log(`Started polling for ${bots.length} bots`);
  }

  async stop(): Promise<void> {
    this.running = false;

    // Clear all polling intervals
    for (const interval of this.pollingIntervals.values()) {
      clearTimeout(interval);
    }
    this.pollingIntervals.clear();
  }

  private async startBotPolling(bot: RegisteredBot): Promise<void> {
    if (!this.running) return;

    try {
      const updates = await this.getUpdates(bot);

      for (const update of updates) {
        await this.processUpdate(bot.agentType, update);
        this.offsets.set(bot.agentType, update.update_id + 1);
      }
    } catch (error) {
      console.error(`Polling error for ${bot.agentType}:`, error);
    }

    // Schedule next poll
    if (this.running) {
      const interval = setTimeout(() => {
        this.startBotPolling(bot);
      }, 1000); // Poll every second
      this.pollingIntervals.set(bot.agentType, interval);
    }
  }

  private async getUpdates(bot: RegisteredBot): Promise<TelegramUpdate[]> {
    const offset = this.offsets.get(bot.agentType) || 0;
    const url = `https://api.telegram.org/bot${bot.token}/getUpdates`;

    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        offset,
        timeout: 30, // Long polling timeout
        allowed_updates: ['message', 'callback_query'],
      }),
    });

    const data = await response.json();

    if (data.ok) {
      return data.result;
    }

    throw new Error(data.description);
  }

  private async processUpdate(botType: AgentType, update: TelegramUpdate): Promise<void> {
    if (update.message) {
      await this.processMessage(botType, update.message);
    }

    if (update.callback_query) {
      await this.processCallbackQuery(botType, update.callback_query);
    }
  }

  private async processMessage(botType: AgentType, message: TelegramMessage): Promise<void> {
    const text = message.text || '';

    const receivedMessage: ReceivedMessage = {
      botType,
      chatId: message.chat.id.toString(),
      messageId: message.message_id,
      text,
      fromUserId: message.from.id,
      fromUsername: message.from.username,
      timestamp: new Date(message.date * 1000),
    };

    // Handle commands
    if (text.startsWith('/start')) {
      this.emit('command:start', receivedMessage);
      return;
    }

    if (text.startsWith('/summary')) {
      this.emit('command:summary', receivedMessage);
      return;
    }

    if (text.startsWith('/status')) {
      this.emit('command:status', receivedMessage);
      return;
    }

    if (text.startsWith('/help')) {
      this.emit('command:help', receivedMessage);
      return;
    }

    // Check if it's a verification code (6 digits)
    if (/^\d{6}$/.test(text.trim())) {
      this.emit('verification:code', receivedMessage);
      return;
    }

    // Regular text message (could be free-text answer)
    this.emit('message:text', receivedMessage);
  }

  private async processCallbackQuery(
    botType: AgentType,
    callback: TelegramCallbackQuery
  ): Promise<void> {
    const receivedCallback: ReceivedCallback = {
      botType,
      callbackId: callback.id,
      chatId: callback.message?.chat.id.toString() || '',
      messageId: callback.message?.message_id || 0,
      data: callback.data || '',
      fromUserId: callback.from.id,
    };

    // Answer callback query (removes loading state)
    await this.answerCallbackQuery(botType, callback.id);

    // Parse callback data
    // Format: "answer:{questionId}:{action}"
    const parts = (callback.data || '').split(':');

    if (parts[0] === 'answer' && parts.length >= 3) {
      this.emit('answer:button', {
        ...receivedCallback,
        questionId: parts[1],
        action: parts.slice(2).join(':'),
      });
      return;
    }

    // Unknown callback
    this.emit('callback:unknown', receivedCallback);
  }

  private async answerCallbackQuery(botType: AgentType, callbackId: string): Promise<void> {
    const bot = this.botRegistry.getBot(botType);
    if (!bot) return;

    const url = `https://api.telegram.org/bot${bot.token}/answerCallbackQuery`;

    await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ callback_query_id: callbackId }),
    });
  }
}
```

---

## Event Types

```typescript
// Events emitted by TelegramReceiver

receiver.on('command:start', (msg: ReceivedMessage) => {
  // User sent /start - trigger chat linking
});

receiver.on('command:summary', (msg: ReceivedMessage) => {
  // User requested summary - ask Monitoring Agent
});

receiver.on('verification:code', (msg: ReceivedMessage) => {
  // User sent 6-digit code - verify chat linking
});

receiver.on('message:text', (msg: ReceivedMessage) => {
  // Free-text message - could be answer to "Other" option
});

receiver.on('answer:button', (data: {
  questionId: string;
  action: string;
  ...ReceivedCallback
}) => {
  // User pressed inline button - process answer
});
```

---

## Validation

```bash
npx tsc --noEmit server/communication/telegram-receiver.ts
npm test -- --grep "telegram-receiver"
```
