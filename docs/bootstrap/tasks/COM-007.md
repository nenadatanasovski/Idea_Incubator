# COM-007: Answer Processing and Routing

---

## Metadata

| Field          | Value                     |
| -------------- | ------------------------- |
| **Phase**      | 0 - Communication Core    |
| **Depends On** | COM-005, COM-006, QUE-001 |
| **Blocks**     | COM-010                   |
| **Priority**   | P1                        |
| **Owner**      | Build Agent               |

---

## Summary

Implement the answer processor that handles incoming answers from Telegram (button presses and free-text), updates the question queue, and unblocks waiting agents.

---

## Requirements

1. **Button Answer Processing**:
   - Parse callback data: `answer:{questionId}:{action}`
   - Validate question exists and is pending
   - Record answer in database
   - Trigger agent unblock

2. **Free-Text Answer Processing**:
   - Track pending "Other" selections
   - Match reply to question
   - Record free-text answer
   - Trigger agent unblock

3. **Answer Confirmation**:
   - Edit original message to show answer
   - Remove inline buttons (answered)
   - Send confirmation message

4. **Agent Notification**:
   - Emit event for agent to resume
   - Include answer in payload
   - Track answer timestamp

---

## Pass Criteria

**PASS** when ALL of the following are true:

| #   | Criterion               | How to Verify                                                                                     |
| --- | ----------------------- | ------------------------------------------------------------------------------------------------- |
| 1   | File exists             | `test -f server/communication/answer-processor.ts` returns 0                                      |
| 2   | Exports AnswerProcessor | `grep -q "export class AnswerProcessor" server/communication/answer-processor.ts` returns 0       |
| 3   | Has processButtonAnswer | `grep -q "processButtonAnswer\|processButton" server/communication/answer-processor.ts` returns 0 |
| 4   | Has processTextAnswer   | `grep -q "processTextAnswer\|processText" server/communication/answer-processor.ts` returns 0     |
| 5   | Updates question queue  | `grep -q "updateQuestion\|markAnswered" server/communication/answer-processor.ts` returns 0       |
| 6   | TypeScript compiles     | `npx tsc --noEmit server/communication/answer-processor.ts` returns 0                             |
| 7   | Unit tests pass         | `npm test -- --grep "answer-processor"` passes                                                    |

**FAIL** if any criterion is not met.

---

## Output Files

```
server/communication/
â””â”€â”€ answer-processor.ts
```

---

## Code Template

```typescript
// server/communication/answer-processor.ts

import { EventEmitter } from "events";
import { Database } from "../../database/db";
import { TelegramSender } from "./telegram-sender";
import { ReceivedCallback, ReceivedMessage } from "./telegram-receiver";

interface Answer {
  questionId: string;
  action: string;
  freeText?: string;
  answeredBy: "user";
  answeredAt: Date;
  channel: "telegram";
}

interface ProcessResult {
  success: boolean;
  questionId: string;
  answer?: Answer;
  error?: string;
}

export class AnswerProcessor extends EventEmitter {
  private db: Database;
  private sender: TelegramSender;
  private pendingOtherReplies: Map<
    string,
    { questionId: string; chatId: string; expiresAt: Date }
  > = new Map();

  constructor(db: Database, sender: TelegramSender) {
    super();
    this.db = db;
    this.sender = sender;
  }

  async processButtonAnswer(callback: {
    questionId: string;
    action: string;
    chatId: string;
    messageId: number;
    botType: string;
  }): Promise<ProcessResult> {
    const { questionId, action, chatId, messageId, botType } = callback;

    // Validate question exists and is pending
    const question = await this.getQuestion(questionId);

    if (!question) {
      return { success: false, questionId, error: "Question not found" };
    }

    if (question.status !== "pending") {
      return { success: false, questionId, error: "Question already answered" };
    }

    // Handle "Other" selection
    if (action === "other") {
      this.setPendingOtherReply(chatId, questionId);

      await this.sender.sendMessage({
        agentType: botType as any,
        text: "ðŸ’¬ Please type your answer:",
      });

      return { success: true, questionId, answer: undefined };
    }

    // Record the answer
    const answer: Answer = {
      questionId,
      action,
      answeredBy: "user",
      answeredAt: new Date(),
      channel: "telegram",
    };

    await this.recordAnswer(answer);
    await this.updateMessageWithAnswer(
      botType as any,
      chatId,
      messageId,
      action,
    );

    // Emit event for waiting agents
    this.emit("answer:received", { questionId, answer });

    return { success: true, questionId, answer };
  }

  async processTextAnswer(message: ReceivedMessage): Promise<ProcessResult> {
    const { chatId, text, botType } = message;

    // Check if this is a reply to "Other"
    const pending = this.getPendingOtherReply(chatId);

    if (!pending) {
      // Not expecting a text answer - could be stray message
      return { success: false, questionId: "", error: "No pending question" };
    }

    const { questionId } = pending;
    this.clearPendingOtherReply(chatId);

    // Validate question still pending
    const question = await this.getQuestion(questionId);

    if (!question || question.status !== "pending") {
      return {
        success: false,
        questionId,
        error: "Question no longer pending",
      };
    }

    // Record the free-text answer
    const answer: Answer = {
      questionId,
      action: "other",
      freeText: text,
      answeredBy: "user",
      answeredAt: new Date(),
      channel: "telegram",
    };

    await this.recordAnswer(answer);

    // Confirm receipt
    await this.sender.sendMessage({
      agentType: botType,
      text: `âœ… Answer recorded: "${text.substring(0, 50)}${text.length > 50 ? "..." : ""}"`,
    });

    // Emit event for waiting agents
    this.emit("answer:received", { questionId, answer });

    return { success: true, questionId, answer };
  }

  private async getQuestion(questionId: string): Promise<any | null> {
    const result = await this.db.query("SELECT * FROM questions WHERE id = ?", [
      questionId,
    ]);
    return result[0] || null;
  }

  private async recordAnswer(answer: Answer): Promise<void> {
    // Insert into answers table
    await this.db.query(
      `INSERT INTO answers (id, question_id, answer_text, selected_option, used_default, answered_at)
       VALUES (?, ?, ?, ?, 0, ?)`,
      [
        `ans-${Date.now()}`,
        answer.questionId,
        answer.freeText || null,
        answer.action,
        answer.answeredAt.toISOString(),
      ],
    );

    // Update question status
    await this.db.query(
      `UPDATE questions SET status = 'answered', answered_at = ? WHERE id = ?`,
      [answer.answeredAt.toISOString(), answer.questionId],
    );
  }

  private async updateMessageWithAnswer(
    botType: any,
    chatId: string,
    messageId: number,
    action: string,
  ): Promise<void> {
    // Edit message to show it was answered
    // This removes the inline keyboard and shows the selection
    const bot = this.sender["botRegistry"].getBot(botType);
    if (!bot) return;

    const url = `https://api.telegram.org/bot${bot.token}/editMessageReplyMarkup`;

    await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        chat_id: chatId,
        message_id: messageId,
        reply_markup: { inline_keyboard: [] }, // Remove buttons
      }),
    });

    // Send confirmation
    await this.sender.sendMessage({
      agentType: botType,
      text: `âœ… Answered: *${action}*`,
      parseMode: "Markdown",
    });
  }

  private setPendingOtherReply(chatId: string, questionId: string): void {
    this.pendingOtherReplies.set(chatId, {
      questionId,
      chatId,
      expiresAt: new Date(Date.now() + 5 * 60 * 1000), // 5 min expiry
    });
  }

  private getPendingOtherReply(chatId: string): { questionId: string } | null {
    const pending = this.pendingOtherReplies.get(chatId);

    if (!pending) return null;

    if (new Date() > pending.expiresAt) {
      this.pendingOtherReplies.delete(chatId);
      return null;
    }

    return { questionId: pending.questionId };
  }

  private clearPendingOtherReply(chatId: string): void {
    this.pendingOtherReplies.delete(chatId);
  }
}
```

---

## Events Emitted

```typescript
// When an answer is received (button or text)
processor.on(
  "answer:received",
  (data: { questionId: string; answer: Answer }) => {
    // Notify waiting agent to resume
    questionQueue.notifyAnswer(data.questionId, data.answer);
  },
);
```

---

## Validation

```bash
npx tsc --noEmit server/communication/answer-processor.ts
npm test -- --grep "answer-processor"
```
