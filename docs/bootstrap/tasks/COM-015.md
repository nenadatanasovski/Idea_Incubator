# COM-015: Communication Hub (Single Entry Point)

---

## Metadata

| Field          | Value                                       |
| -------------- | ------------------------------------------- |
| **Phase**      | 0 - Communication Core                      |
| **Depends On** | COM-002, COM-004, COM-010, COM-011, COM-014 |
| **Blocks**     | All agent tasks                             |
| **Priority**   | P1                                          |
| **Owner**      | Build Agent                                 |

---

## Summary

Implement the Communication Hub - the single entry point that all agents use for human communication. This is the facade that ties together registration, messaging, questions, and answers.

---

## Context

### The Problem

Right now we have:

- BotRegistry (COM-002)
- TelegramSender (COM-004)
- NotificationDispatcher (COM-010)
- ExecutionGate (COM-011)
- AgentHandshake (COM-014)

But agents shouldn't need to know about all these pieces. They need ONE simple interface:

```typescript
// What agents want:
await comm.register();
await comm.askQuestion({ ... });
await comm.notify({ ... });
await comm.shutdown();
```

### The Hub Pattern

```
                    ┌─────────────────────────────────────────────┐
                    │            COMMUNICATION HUB                 │
                    │         (Single Entry Point)                 │
                    ├─────────────────────────────────────────────┤
                    │                                              │
 ┌──────────┐       │  register()    ──▶  AgentHandshake          │
 │  Agent   │──────▶│  askQuestion() ──▶  QuestionQueue + Gate    │
 │          │◀──────│  notify()      ──▶  NotificationDispatcher  │
 └──────────┘       │  waitForAnswer()──▶  ExecutionGate          │
                    │  shutdown()    ──▶  AgentHandshake          │
                    │                                              │
                    └─────────────────────────────────────────────┘
                                         │
                    ┌────────────────────┼────────────────────┐
                    ▼                    ▼                    ▼
              ┌──────────┐        ┌──────────┐        ┌──────────┐
              │ Telegram │        │  Email   │        │   Web    │
              │   Bots   │        │  SMTP    │        │  Socket  │
              └──────────┘        └──────────┘        └──────────┘
```

---

## Requirements

1. **Single Instance** (Singleton):
   - One hub per process
   - Shared across all agents
   - Thread-safe

2. **Simple Agent API**:
   - `register(agentId, agentType)` → Handshake + ready confirmation
   - `askQuestion(question)` → Question ID, handles blocking
   - `notify(message)` → Fire and forget
   - `waitForAnswer(questionId)` → Blocks until answered
   - `shutdown(agentId)` → Graceful disconnect

3. **Automatic State Management**:
   - Track registered agents
   - Track pending questions per agent
   - Track communication health

4. **Error Handling**:
   - Graceful degradation if channels fail
   - Retry logic built-in
   - Clear error messages

5. **Observability**:
   - Events for all state changes
   - Metrics for message counts
   - Health check endpoint

---

## Pass Criteria

**PASS** when ALL of the following are true:

| #   | Criterion                | How to Verify                                                                   |
| --- | ------------------------ | ------------------------------------------------------------------------------- |
| 1   | File exists              | `test -f server/communication/hub.ts` returns 0                                 |
| 2   | Exports CommunicationHub | `grep -q "export class CommunicationHub" server/communication/hub.ts` returns 0 |
| 3   | Has register method      | `grep -q "register(" server/communication/hub.ts` returns 0                     |
| 4   | Has askQuestion method   | `grep -q "askQuestion(" server/communication/hub.ts` returns 0                  |
| 5   | Has notify method        | `grep -q "notify(" server/communication/hub.ts` returns 0                       |
| 6   | Has waitForAnswer method | `grep -q "waitForAnswer(" server/communication/hub.ts` returns 0                |
| 7   | Is singleton             | `grep -q "getInstance\|instance" server/communication/hub.ts` returns 0         |
| 8   | TypeScript compiles      | `npx tsc --noEmit server/communication/hub.ts` returns 0                        |

**FAIL** if any criterion is not met.

---

## Output Files

```
server/communication/
├── hub.ts
└── index.ts  (re-exports hub as main entry)
```

---

## Code Template

```typescript
// server/communication/hub.ts

import { EventEmitter } from "events";
import { Database } from "../../database/db";
import { BotRegistry, AgentType } from "./bot-registry";
import { NotificationDispatcher } from "./notification-dispatcher";
import { ExecutionGate } from "./execution-gate";
import { AgentHandshake } from "./agent-handshake";
import { AnswerProcessor } from "./answer-processor";
import { TelegramReceiver } from "./telegram-receiver";

type QuestionType =
  | "BLOCKING"
  | "CLARIFYING"
  | "CONFIRMING"
  | "PREFERENCE"
  | "ALERT"
  | "ESCALATION"
  | "APPROVAL"
  | "DECISION";

interface QuestionOptions {
  type: QuestionType;
  content: string;
  options?: { label: string; action: string; description?: string }[];
  context?: any;
  timeoutMs?: number;
  defaultAnswer?: string;
}

interface QuestionResult {
  questionId: string;
  answered: boolean;
  answer?: any;
  timedOut: boolean;
  error?: string;
}

interface NotifyOptions {
  content: string;
  level?: "info" | "warning" | "error";
  metadata?: Record<string, any>;
}

interface HubConfig {
  autoStart: boolean; // Start receiver on init
  healthCheckIntervalMs: number;
}

const DEFAULT_CONFIG: HubConfig = {
  autoStart: true,
  healthCheckIntervalMs: 60_000,
};

export class CommunicationHub extends EventEmitter {
  private static instance: CommunicationHub | null = null;

  private db: Database;
  private config: HubConfig;
  private initialized: boolean = false;

  // Sub-components
  private botRegistry!: BotRegistry;
  private dispatcher!: NotificationDispatcher;
  private executionGate!: ExecutionGate;
  private handshake!: AgentHandshake;
  private answerProcessor!: AnswerProcessor;
  private receiver!: TelegramReceiver;

  // State
  private registeredAgents: Map<string, { type: AgentType; ready: boolean }> =
    new Map();
  private pendingQuestions: Map<string, string[]> = new Map(); // agentId -> questionIds

  private constructor(db: Database, config?: Partial<HubConfig>) {
    super();
    this.db = db;
    this.config = { ...DEFAULT_CONFIG, ...config };
  }

  static getInstance(
    db?: Database,
    config?: Partial<HubConfig>,
  ): CommunicationHub {
    if (!CommunicationHub.instance) {
      if (!db) {
        throw new Error("Database required for first initialization");
      }
      CommunicationHub.instance = new CommunicationHub(db, config);
    }
    return CommunicationHub.instance;
  }

  async initialize(): Promise<void> {
    if (this.initialized) {
      return;
    }

    console.log("[Hub] Initializing communication hub...");

    // Initialize sub-components
    this.botRegistry = new BotRegistry();
    await this.botRegistry.initialize();

    this.dispatcher = new NotificationDispatcher(this.db, this.botRegistry);
    this.executionGate = new ExecutionGate(this.db);
    this.handshake = new AgentHandshake(
      this.db,
      this.botRegistry,
      this.dispatcher,
    );
    this.answerProcessor = new AnswerProcessor(this.db);
    this.receiver = new TelegramReceiver(this.botRegistry);

    // Wire up event handlers
    this.setupEventHandlers();

    // Start receiver if configured
    if (this.config.autoStart) {
      await this.receiver.start();
    }

    // Start health check
    this.startHealthCheck();

    this.initialized = true;
    console.log("[Hub] Communication hub initialized");
    this.emit("hub:ready");
  }

  private setupEventHandlers(): void {
    // Answer received → route to waiting agents
    this.answerProcessor.on("answer:received", async (data) => {
      const { questionId, agentId, answer } = data;
      await this.executionGate.onQuestionAnswered(
        questionId,
        agentId,
        undefined,
        answer,
      );
      this.emit("answer:received", data);
    });

    // Agent state changes
    this.handshake.on("agent:ready", (data) => {
      const agent = this.registeredAgents.get(data.agentId);
      if (agent) {
        agent.ready = true;
      }
      this.emit("agent:ready", data);
    });

    this.handshake.on("agent:degraded", (data) => {
      this.emit("agent:degraded", data);
    });

    // Telegram events → answer processor
    this.receiver.on("answer:button", async (data) => {
      await this.answerProcessor.processButtonAnswer(data);
    });

    this.receiver.on("answer:text", async (data) => {
      await this.answerProcessor.processTextAnswer(data);
    });
  }

  // ============================================
  // PUBLIC API - What agents actually use
  // ============================================

  /**
   * Register an agent with the communication system.
   * Sends hello message and waits for acknowledgment.
   */
  async register(
    agentId: string,
    agentType: AgentType,
    sessionId?: string,
  ): Promise<{ success: boolean; error?: string }> {
    if (!this.initialized) {
      await this.initialize();
    }

    console.log(`[Hub] Registering agent: ${agentId}`);

    const result = await this.handshake.register(agentId, agentType, sessionId);

    if (result.success) {
      this.registeredAgents.set(agentId, {
        type: agentType,
        ready: result.state === "READY",
      });
      this.pendingQuestions.set(agentId, []);
    }

    return {
      success: result.success,
      error: result.error,
    };
  }

  /**
   * Ask a question and optionally wait for the answer.
   * For BLOCKING questions, this will halt until answered.
   */
  async askQuestion(
    agentId: string,
    options: QuestionOptions,
  ): Promise<QuestionResult> {
    if (!this.isRegistered(agentId)) {
      return {
        questionId: "",
        answered: false,
        timedOut: false,
        error: `Agent ${agentId} not registered`,
      };
    }

    const agent = this.registeredAgents.get(agentId)!;
    const questionId = this.generateQuestionId();

    // Create question in database
    await this.db.query(
      `
      INSERT INTO questions (id, agent_id, type, content, status, created_at)
      VALUES (?, ?, ?, ?, 'pending', ?)
    `,
      [
        questionId,
        agentId,
        options.type,
        options.content,
        new Date().toISOString(),
      ],
    );

    // Track pending question
    this.pendingQuestions.get(agentId)!.push(questionId);

    // Send via dispatcher
    const sendResult = await this.dispatcher.notify({
      agentId,
      agentType: agent.type,
      type: options.type,
      content: options.content,
      options: options.options,
      questionId,
      metadata: options.context,
    });

    if (!sendResult.delivered) {
      return {
        questionId,
        answered: false,
        timedOut: false,
        error: "Failed to deliver question",
      };
    }

    // For blocking questions, wait for answer
    if (this.isBlockingType(options.type)) {
      const clearance = await this.executionGate.waitForClearance(
        agentId,
        undefined,
        options.timeoutMs,
      );

      // Remove from pending
      const pending = this.pendingQuestions.get(agentId)!;
      const idx = pending.indexOf(questionId);
      if (idx > -1) pending.splice(idx, 1);

      if (clearance.cleared) {
        return {
          questionId,
          answered: true,
          answer: clearance.answer,
          timedOut: false,
        };
      } else {
        return {
          questionId,
          answered: false,
          timedOut: clearance.reason === "timeout",
          error:
            clearance.reason === "timeout" ? "Question timed out" : "Cancelled",
        };
      }
    }

    // Non-blocking - return immediately
    return {
      questionId,
      answered: false,
      timedOut: false,
    };
  }

  /**
   * Wait for a specific question to be answered.
   */
  async waitForAnswer(
    agentId: string,
    questionId: string,
    timeoutMs?: number,
  ): Promise<{ answered: boolean; answer?: any; timedOut: boolean }> {
    const result = await this.executionGate.waitForClearance(
      agentId,
      undefined,
      timeoutMs,
    );

    return {
      answered: result.cleared,
      answer: result.answer,
      timedOut: result.reason === "timeout",
    };
  }

  /**
   * Send a notification (fire and forget).
   */
  async notify(
    agentId: string,
    options: NotifyOptions,
  ): Promise<{ success: boolean }> {
    if (!this.isRegistered(agentId)) {
      console.warn(`[Hub] Agent ${agentId} not registered, sending anyway`);
    }

    const agent = this.registeredAgents.get(agentId);
    const agentType = agent?.type || "SYSTEM";

    const result = await this.dispatcher.notify({
      agentId,
      agentType,
      type: "ALERT",
      content: options.content,
      metadata: options.metadata,
    });

    return { success: result.delivered };
  }

  /**
   * Check if agent can proceed (no blocking questions).
   */
  async canProceed(agentId: string, sessionId?: string): Promise<boolean> {
    return this.executionGate.canProceed(agentId, sessionId);
  }

  /**
   * Gracefully shutdown an agent's communication.
   */
  async shutdown(agentId: string): Promise<void> {
    console.log(`[Hub] Shutting down agent: ${agentId}`);

    await this.handshake.unregister(agentId);
    this.registeredAgents.delete(agentId);
    this.pendingQuestions.delete(agentId);

    this.emit("agent:shutdown", { agentId });
  }

  // ============================================
  // UTILITIES
  // ============================================

  isRegistered(agentId: string): boolean {
    return this.registeredAgents.has(agentId);
  }

  isReady(agentId: string): boolean {
    const agent = this.registeredAgents.get(agentId);
    return agent?.ready ?? false;
  }

  getRegisteredAgents(): string[] {
    return Array.from(this.registeredAgents.keys());
  }

  getPendingQuestions(agentId: string): string[] {
    return this.pendingQuestions.get(agentId) || [];
  }

  getStatus(): {
    initialized: boolean;
    agentCount: number;
    pendingQuestionCount: number;
  } {
    let pendingCount = 0;
    for (const questions of this.pendingQuestions.values()) {
      pendingCount += questions.length;
    }

    return {
      initialized: this.initialized,
      agentCount: this.registeredAgents.size,
      pendingQuestionCount: pendingCount,
    };
  }

  private isBlockingType(type: QuestionType): boolean {
    return ["BLOCKING", "APPROVAL", "ESCALATION", "DECISION"].includes(type);
  }

  private generateQuestionId(): string {
    return `q_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private startHealthCheck(): void {
    setInterval(() => {
      for (const agentId of this.registeredAgents.keys()) {
        this.handshake.healthCheck(agentId);
      }
    }, this.config.healthCheckIntervalMs);
  }

  // For testing
  static resetInstance(): void {
    CommunicationHub.instance = null;
  }
}

// Export singleton getter
export function getHub(db?: Database): CommunicationHub {
  return CommunicationHub.getInstance(db);
}
```

---

## Index File

```typescript
// server/communication/index.ts

export { CommunicationHub, getHub } from "./hub";
export { BotRegistry } from "./bot-registry";
export { TelegramSender } from "./telegram-sender";
export { TelegramReceiver } from "./telegram-receiver";
export { NotificationDispatcher } from "./notification-dispatcher";
export { ExecutionGate } from "./execution-gate";
export { AgentHandshake } from "./agent-handshake";
export { AnswerProcessor } from "./answer-processor";
export { MessageTemplates } from "./message-templates";
```

---

## Usage Example

```typescript
// In any agent

import { getHub } from "../communication";

class SpecAgent {
  private agentId = "spec-agent-123";
  private hub = getHub();

  async start() {
    // One line to register and confirm communication works
    const { success, error } = await this.hub.register(this.agentId, "SPEC");
    if (!success) {
      throw new Error(`Failed to register: ${error}`);
    }

    // Now can ask questions
    await this.doWork();
  }

  async doWork() {
    // Ask a blocking question
    const result = await this.hub.askQuestion(this.agentId, {
      type: "BLOCKING",
      content: "Which authentication approach should I use?",
      options: [
        { label: "JWT Tokens", action: "jwt", description: "Stateless" },
        { label: "Sessions", action: "session", description: "Stateful" },
      ],
      timeoutMs: 900_000, // 15 min
    });

    if (result.answered) {
      console.log(`User chose: ${result.answer}`);
    } else if (result.timedOut) {
      console.log("Question timed out, using default");
    }

    // Send a notification
    await this.hub.notify(this.agentId, {
      content: "Spec generation complete!",
    });
  }

  async shutdown() {
    await this.hub.shutdown(this.agentId);
  }
}
```

---

## Validation

```bash
npx tsc --noEmit server/communication/hub.ts
npm test -- --grep "communication-hub"
```
