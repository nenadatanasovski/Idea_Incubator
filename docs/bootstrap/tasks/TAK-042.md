# TAK-042: Predictive Blocker Service

---

## Metadata

| Field          | Value                   |
| -------------- | ----------------------- |
| **Phase**      | Additional Capabilities |
| **Depends On** | TAK-016                 |
| **Blocks**     | None                    |
| **Priority**   | P3                      |
| **Owner**      | Build Agent             |

---

## Summary

Implement a PredictiveBlocker service that anticipates when tasks will become blocked before it happens, allowing proactive intervention and smoother execution.

---

## Requirements

1. **Pattern Analysis**:
   - Analyze historical task patterns that lead to blocks
   - Track common blockers by category
   - Build predictive models from failure data

2. **Resource Monitoring**:
   - Monitor agent availability
   - Track dependency completion rates
   - Watch for resource contention

3. **Early Warning System**:
   - Alert users before predicted block
   - Suggest preventive actions
   - Calculate block probability score

4. **Learning System**:
   - Learn from historical data
   - Improve predictions over time
   - Feed insights to SIA

---

## Pass Criteria

**PASS** when ALL of the following are true:

| #   | Criterion             | How to Verify                                                                           |
| --- | --------------------- | --------------------------------------------------------------------------------------- |
| 1   | File exists           | `test -f server/services/task-agent/predictive-blocker.ts` returns 0                    |
| 2   | Has prediction method | `grep -q "predict\|Predict" server/services/task-agent/predictive-blocker.ts` returns 0 |
| 3   | Has pattern analysis  | `grep -q "pattern\|Pattern" server/services/task-agent/predictive-blocker.ts` returns 0 |
| 4   | Compiles              | `npx tsc --noEmit server/services/task-agent/predictive-blocker.ts` passes              |

**FAIL** if any criterion is not met.

---

## Output Files

```
server/services/task-agent/
└── predictive-blocker.ts
```

---

## Code Template

```typescript
// Predictive Blocker Service
// Anticipates task blocks before they happen

import { db } from "../../database";
import type { Task, TaskBlock } from "../../../types/task-agent";

interface BlockPrediction {
  taskId: string;
  probability: number; // 0-1
  predictedBlockType: string;
  predictedReason: string;
  suggestedActions: string[];
  confidence: number;
}

interface PatternData {
  category: string;
  commonBlockers: string[];
  avgTimeToBlock: number;
  riskFactors: string[];
}

export class PredictiveBlocker {
  private patterns: Map<string, PatternData> = new Map();

  constructor() {
    this.loadHistoricalPatterns();
  }

  async loadHistoricalPatterns(): Promise<void> {
    // Load and analyze historical block data
    const blocks = db
      .prepare(
        `
      SELECT tb.*, t.category, t.title
      FROM task_blocks tb
      JOIN tasks t ON tb.task_id = t.id
      WHERE tb.resolved_at IS NOT NULL
      ORDER BY tb.created_at DESC
      LIMIT 1000
    `,
      )
      .all();

    // Build pattern map by category
    // TODO: Implement pattern analysis
  }

  async predictBlocks(taskId: string): Promise<BlockPrediction | null> {
    const task = db
      .prepare("SELECT * FROM tasks WHERE id = ?")
      .get(taskId) as Task;
    if (!task) return null;

    const prediction: BlockPrediction = {
      taskId,
      probability: 0,
      predictedBlockType: "",
      predictedReason: "",
      suggestedActions: [],
      confidence: 0.5,
    };

    // Check for patterns matching this task's category
    const pattern = this.patterns.get(task.category);
    if (pattern) {
      // Apply pattern-based prediction
      prediction.probability = this.calculateProbability(task, pattern);
      prediction.predictedBlockType = pattern.commonBlockers[0] || "unknown";
      prediction.predictedReason = `Tasks in ${task.category} category commonly blocked by: ${pattern.commonBlockers.join(", ")}`;
      prediction.suggestedActions = this.generateSuggestions(task, pattern);
    }

    // Check dependency health
    const dependencyRisk = await this.assessDependencyRisk(taskId);
    prediction.probability = Math.max(prediction.probability, dependencyRisk);

    return prediction.probability > 0.3 ? prediction : null;
  }

  private calculateProbability(task: Task, pattern: PatternData): number {
    let probability = 0;

    // Factor in category-specific risk
    const categoryRisk = pattern.commonBlockers.length / 10;
    probability += categoryRisk;

    // Factor in task complexity (description length as proxy)
    if (task.description.length < 100) {
      probability += 0.1; // Short descriptions often lack clarity
    }

    // Factor in missing tests
    if (!task.apiTestCases?.length && !task.uiTestCases?.length) {
      probability += 0.2;
    }

    return Math.min(probability, 1);
  }

  private async assessDependencyRisk(taskId: string): Promise<number> {
    const deps = db
      .prepare(
        `
      SELECT t.status, t.validation_status
      FROM task_relationships tr
      JOIN tasks t ON tr.target_task_id = t.id
      WHERE tr.source_task_id = ? AND tr.relationship_type = 'depends_on'
    `,
      )
      .all(taskId);

    if (!deps.length) return 0;

    const staleDeps = deps.filter((d: any) => d.status === "stale").length;
    const blockedDeps = deps.filter((d: any) => d.status === "blocked").length;

    return staleDeps * 0.1 + blockedDeps * 0.3;
  }

  private generateSuggestions(task: Task, pattern: PatternData): string[] {
    const suggestions: string[] = [];

    // Add category-specific suggestions
    for (const factor of pattern.riskFactors) {
      suggestions.push(`Address risk factor: ${factor}`);
    }

    // Generic suggestions
    if (!task.acceptanceCriteria?.length) {
      suggestions.push("Add acceptance criteria to clarify requirements");
    }

    if (!task.apiTestCases?.length) {
      suggestions.push("Add API test cases to prevent validation blocks");
    }

    return suggestions;
  }

  async recordBlockOutcome(taskId: string, wasBlocked: boolean): Promise<void> {
    // Record for learning
    // TODO: Update pattern data based on outcome
  }
}

export default PredictiveBlocker;
```

---

## Gotchas

- Predictions are probabilistic - don't block tasks based solely on predictions
- Historical data may not represent current patterns
- New task categories won't have pattern data initially

---

## Validation

```bash
# Type check
npx tsc --noEmit server/services/task-agent/predictive-blocker.ts

# Run unit tests
npm test -- --grep "predictive-blocker"
```

---

## Next Steps

After completing this task:

1. Integrate with TaskAgent main loop
2. Add notification for high-probability predictions
3. Build UI component to show predictions
