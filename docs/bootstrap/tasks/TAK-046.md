# TAK-046: Cross-Project Dependencies Service

---

## Metadata

| Field          | Value                   |
| -------------- | ----------------------- |
| **Phase**      | Additional Capabilities |
| **Depends On** | TAK-013                 |
| **Blocks**     | None                    |
| **Priority**   | P3                      |
| **Owner**      | Build Agent             |

---

## Summary

Implement a CrossProjectDeps service that tracks and manages dependencies across different projects and ideas, enabling coordinated multi-project work.

---

## Requirements

1. **Cross-Project Linking**:
   - Link tasks across different projects
   - Track shared dependencies
   - Visualize cross-project relationships

2. **Blocker Detection**:
   - Detect blockers from other projects
   - Alert on cross-project delays
   - Identify critical cross-project paths

3. **Graph Visualization**:
   - Generate multi-project dependency graph
   - Highlight cross-project edges
   - Show project boundaries

4. **Coordination**:
   - Coordinate work across projects
   - Suggest parallel work opportunities
   - Track cross-project milestones

---

## Pass Criteria

**PASS** when ALL of the following are true:

| #   | Criterion                | How to Verify                                                                                       |
| --- | ------------------------ | --------------------------------------------------------------------------------------------------- |
| 1   | File exists              | `test -f server/services/task-agent/cross-project-deps.ts` returns 0                                |
| 2   | Has cross-project method | `grep -q "crossProject\|cross.*project" server/services/task-agent/cross-project-deps.ts` returns 0 |
| 3   | Has graph generation     | `grep -q "graph\|Graph" server/services/task-agent/cross-project-deps.ts` returns 0                 |
| 4   | Compiles                 | `npx tsc --noEmit server/services/task-agent/cross-project-deps.ts` passes                          |

**FAIL** if any criterion is not met.

---

## Output Files

```
server/services/task-agent/
└── cross-project-deps.ts
```

---

## Code Template

```typescript
// Cross-Project Dependencies Service
// Manages dependencies spanning multiple projects

import { db } from "../../database";

interface CrossProjectLink {
  id: string;
  sourceProjectId: string;
  sourceTaskId: string;
  targetProjectId: string;
  targetTaskId: string;
  linkType: "depends_on" | "blocks" | "related_to";
  description?: string;
  createdAt: string;
}

interface CrossProjectBlocker {
  blockedProjectId: string;
  blockedTaskId: string;
  blockingProjectId: string;
  blockingTaskId: string;
  severity: "critical" | "high" | "medium";
  estimatedDelay: number; // days
}

interface ProjectNode {
  projectId: string;
  projectName: string;
  taskCount: number;
  completedCount: number;
  blockedCount: number;
  crossProjectDeps: number;
}

interface DependencyGraph {
  nodes: ProjectNode[];
  edges: CrossProjectLink[];
  criticalPath: string[]; // Task IDs
}

export class CrossProjectDeps {
  async createCrossProjectLink(
    sourceTaskId: string,
    targetTaskId: string,
    linkType: "depends_on" | "blocks" | "related_to",
    description?: string,
  ): Promise<CrossProjectLink> {
    // Get project IDs for both tasks
    const sourceTask = db
      .prepare("SELECT project_id FROM tasks WHERE id = ?")
      .get(sourceTaskId) as { project_id: string };
    const targetTask = db
      .prepare("SELECT project_id FROM tasks WHERE id = ?")
      .get(targetTaskId) as { project_id: string };

    if (!sourceTask || !targetTask) {
      throw new Error("Task not found");
    }

    if (sourceTask.project_id === targetTask.project_id) {
      throw new Error("Tasks are in the same project - use regular dependency");
    }

    const id = `xdep-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;

    // Create the cross-project relationship
    db.prepare(
      `
      INSERT INTO task_relationships (id, source_task_id, target_task_id, relationship_type, created_at)
      VALUES (?, ?, ?, ?, datetime('now'))
    `,
    ).run(id, sourceTaskId, targetTaskId, linkType);

    const link: CrossProjectLink = {
      id,
      sourceProjectId: sourceTask.project_id,
      sourceTaskId,
      targetProjectId: targetTask.project_id,
      targetTaskId,
      linkType,
      description,
      createdAt: new Date().toISOString(),
    };

    return link;
  }

  async getCrossProjectBlockers(): Promise<CrossProjectBlocker[]> {
    const blockers = db
      .prepare(
        `
      SELECT
        t1.project_id as blocked_project,
        t1.id as blocked_task,
        t2.project_id as blocking_project,
        t2.id as blocking_task,
        t1.status as blocked_status,
        t2.status as blocking_status
      FROM task_relationships tr
      JOIN tasks t1 ON tr.source_task_id = t1.id
      JOIN tasks t2 ON tr.target_task_id = t2.id
      WHERE tr.relationship_type = 'depends_on'
        AND t1.project_id != t2.project_id
        AND t1.status IN ('pending', 'blocked')
        AND t2.status NOT IN ('completed', 'cancelled')
    `,
      )
      .all() as any[];

    return blockers.map((b) => ({
      blockedProjectId: b.blocked_project,
      blockedTaskId: b.blocked_task,
      blockingProjectId: b.blocking_project,
      blockingTaskId: b.blocking_task,
      severity: this.calculateSeverity(b),
      estimatedDelay: this.estimateDelay(b.blocking_task),
    }));
  }

  private calculateSeverity(blocker: any): "critical" | "high" | "medium" {
    // Check if blocking task is stale
    if (blocker.blocking_status === "stale") return "critical";
    if (blocker.blocking_status === "blocked") return "high";
    return "medium";
  }

  private estimateDelay(taskId: string): number {
    // Estimate based on task effort
    const task = db
      .prepare("SELECT estimated_effort FROM tasks WHERE id = ?")
      .get(taskId) as any;
    if (!task?.estimated_effort) return 1;

    const effort = task.estimated_effort;
    if (effort.includes("d")) return parseInt(effort);
    if (effort.includes("h")) return Math.ceil(parseInt(effort) / 8);
    return 1;
  }

  async generateDependencyGraph(
    projectIds?: string[],
  ): Promise<DependencyGraph> {
    // Get projects
    let projectQuery = "SELECT DISTINCT project_id FROM tasks";
    if (projectIds?.length) {
      projectQuery += ` WHERE project_id IN (${projectIds.map(() => "?").join(",")})`;
    }

    const projects = db.prepare(projectQuery).all(projectIds || []) as {
      project_id: string;
    }[];

    // Build nodes
    const nodes: ProjectNode[] = [];
    for (const p of projects) {
      const stats = db
        .prepare(
          `
        SELECT
          COUNT(*) as total,
          SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed,
          SUM(CASE WHEN status = 'blocked' THEN 1 ELSE 0 END) as blocked
        FROM tasks WHERE project_id = ?
      `,
        )
        .get(p.project_id) as any;

      const crossDeps = db
        .prepare(
          `
        SELECT COUNT(*) as count
        FROM task_relationships tr
        JOIN tasks t1 ON tr.source_task_id = t1.id
        JOIN tasks t2 ON tr.target_task_id = t2.id
        WHERE (t1.project_id = ? OR t2.project_id = ?)
          AND t1.project_id != t2.project_id
      `,
        )
        .get(p.project_id, p.project_id) as { count: number };

      nodes.push({
        projectId: p.project_id,
        projectName: p.project_id, // TODO: Get actual name
        taskCount: stats.total,
        completedCount: stats.completed,
        blockedCount: stats.blocked,
        crossProjectDeps: crossDeps.count,
      });
    }

    // Build edges (cross-project only)
    const edges = db
      .prepare(
        `
      SELECT
        tr.id,
        t1.project_id as source_project,
        tr.source_task_id,
        t2.project_id as target_project,
        tr.target_task_id,
        tr.relationship_type,
        tr.created_at
      FROM task_relationships tr
      JOIN tasks t1 ON tr.source_task_id = t1.id
      JOIN tasks t2 ON tr.target_task_id = t2.id
      WHERE t1.project_id != t2.project_id
    `,
      )
      .all() as any[];

    const links: CrossProjectLink[] = edges.map((e) => ({
      id: e.id,
      sourceProjectId: e.source_project,
      sourceTaskId: e.source_task_id,
      targetProjectId: e.target_project,
      targetTaskId: e.target_task_id,
      linkType: e.relationship_type,
      createdAt: e.created_at,
    }));

    // Calculate critical path
    const criticalPath = await this.calculateCriticalPath(links);

    return { nodes, edges: links, criticalPath };
  }

  private async calculateCriticalPath(
    links: CrossProjectLink[],
  ): Promise<string[]> {
    // Simple critical path - longest chain of dependencies
    const graph = new Map<string, string[]>();

    for (const link of links) {
      if (link.linkType === "depends_on") {
        if (!graph.has(link.sourceTaskId)) {
          graph.set(link.sourceTaskId, []);
        }
        graph.get(link.sourceTaskId)!.push(link.targetTaskId);
      }
    }

    // Find longest path (simplified DFS)
    let longestPath: string[] = [];

    const dfs = (taskId: string, path: string[]): void => {
      const newPath = [...path, taskId];
      if (newPath.length > longestPath.length) {
        longestPath = newPath;
      }

      const deps = graph.get(taskId) || [];
      for (const dep of deps) {
        if (!path.includes(dep)) {
          dfs(dep, newPath);
        }
      }
    };

    for (const taskId of graph.keys()) {
      dfs(taskId, []);
    }

    return longestPath;
  }

  async suggestParallelWork(projectId: string): Promise<string[]> {
    // Find tasks that can be worked on in parallel
    const tasks = db
      .prepare(
        `
      SELECT t.id
      FROM tasks t
      WHERE t.project_id = ?
        AND t.status = 'pending'
        AND NOT EXISTS (
          SELECT 1 FROM task_relationships tr
          JOIN tasks t2 ON tr.target_task_id = t2.id
          WHERE tr.source_task_id = t.id
            AND tr.relationship_type = 'depends_on'
            AND t2.status NOT IN ('completed', 'cancelled')
        )
    `,
      )
      .all(projectId) as { id: string }[];

    return tasks.map((t) => t.id);
  }
}

export default CrossProjectDeps;
```

---

## Gotchas

- Cross-project cycles are harder to detect
- Different projects may have different priorities
- Need to coordinate across project owners

---

## Validation

```bash
# Type check
npx tsc --noEmit server/services/task-agent/cross-project-deps.ts

# Run unit tests
npm test -- --grep "cross-project"
```

---

## Next Steps

After completing this task:

1. Add to DependencyGraph UI component
2. Create cross-project dashboard view
3. Add notifications for cross-project blockers
