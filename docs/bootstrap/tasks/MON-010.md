# MON-010: Historical Baseline Learning

---

## Metadata

| Field | Value |
|-------|-------|
| **Phase** | 2 - Monitoring Agent |
| **Depends On** | MON-005, MON-006 |
| **Blocks** | None |
| **Priority** | P2 |
| **Owner** | Build Agent |

---

## Summary

Implement historical baseline learning for the Detection Engine. This component learns normal patterns from past agent behavior to improve detection accuracy over time.

---

## Context

Without historical baselines, the Detection Engine uses static thresholds. This works initially but doesn't adapt to:
- Individual agent quirks (some agents naturally take longer)
- Project-specific patterns (complex projects have longer task durations)
- Time-of-day variations (CI might be slower during peak hours)

Historical learning provides adaptive thresholds based on actual observed behavior.

---

## Requirements

1. **Data Collection**:
   - Store task durations by agent type and task type
   - Store error frequencies by agent
   - Store observation counts per time window
   - Rolling window (7 days default)

2. **Baseline Calculation**:
   - Mean and standard deviation for task durations
   - Normal error rate per agent
   - Typical observation patterns
   - Confidence scores based on sample size

3. **Adaptive Thresholds**:
   - Replace static thresholds with learned values
   - Fall back to static when insufficient data
   - Gradual threshold adjustment (not sudden)

4. **Anomaly Detection**:
   - Flag when current behavior deviates from baseline
   - Calculate deviation in standard deviations
   - Report confidence in anomaly detection

---

## Pass Criteria

**PASS** when ALL of the following are true:

| # | Criterion | How to Verify |
|---|-----------|---------------|
| 1 | File exists | `test -f agents/monitoring/historical-baseline.ts` returns 0 |
| 2 | Exports HistoricalBaseline | `grep -q "export class HistoricalBaseline" agents/monitoring/historical-baseline.ts` returns 0 |
| 3 | Has record method | `grep -q "recordObservation\|record(" agents/monitoring/historical-baseline.ts` returns 0 |
| 4 | Has getBaseline method | `grep -q "getBaseline\|getThreshold" agents/monitoring/historical-baseline.ts` returns 0 |
| 5 | Calculates statistics | `grep -q "mean\|stddev\|deviation" agents/monitoring/historical-baseline.ts` returns 0 |
| 6 | Uses rolling window | `grep -q "window\|days\|expiry" agents/monitoring/historical-baseline.ts` returns 0 |
| 7 | TypeScript compiles | `npx tsc --noEmit agents/monitoring/historical-baseline.ts` returns 0 |
| 8 | Unit tests pass | `npm test -- --grep "historical-baseline"` passes |

**FAIL** if any criterion is not met.

---

## Output Files

```
agents/monitoring/
└── historical-baseline.ts
```

---

## Code Template

```typescript
// agents/monitoring/historical-baseline.ts

export interface Observation {
  agentId: string;
  agentType: string;
  taskType: string;
  duration: number;  // ms
  success: boolean;
  timestamp: Date;
}

export interface Baseline {
  taskType: string;
  sampleSize: number;
  mean: number;
  stddev: number;
  min: number;
  max: number;
  confidence: number;  // 0-1 based on sample size
}

export interface AnomalyResult {
  isAnomaly: boolean;
  deviationScore: number;  // in standard deviations
  expectedRange: { min: number; max: number };
  actualValue: number;
  confidence: number;
}

export class HistoricalBaseline {
  private observations: Observation[] = [];
  private windowDays: number;
  private minSamplesForConfidence: number;

  constructor(config: HistoricalConfig = {}) {
    this.windowDays = config.windowDays || 7;
    this.minSamplesForConfidence = config.minSamplesForConfidence || 30;
  }

  recordObservation(obs: Observation): void {
    this.observations.push(obs);
    this.pruneExpired();
  }

  getBaseline(agentType: string, taskType: string): Baseline | null {
    const relevant = this.observations.filter(o =>
      o.agentType === agentType &&
      o.taskType === taskType &&
      o.success  // Only successful observations
    );

    if (relevant.length < 3) {
      return null;  // Insufficient data
    }

    const durations = relevant.map(o => o.duration);
    const mean = this.calculateMean(durations);
    const stddev = this.calculateStdDev(durations, mean);

    return {
      taskType,
      sampleSize: relevant.length,
      mean,
      stddev,
      min: Math.min(...durations),
      max: Math.max(...durations),
      confidence: Math.min(1, relevant.length / this.minSamplesForConfidence),
    };
  }

  detectAnomaly(
    agentType: string,
    taskType: string,
    actualDuration: number,
    deviationThreshold: number = 2
  ): AnomalyResult {
    const baseline = this.getBaseline(agentType, taskType);

    if (!baseline || baseline.confidence < 0.3) {
      // Insufficient data, can't detect anomaly
      return {
        isAnomaly: false,
        deviationScore: 0,
        expectedRange: { min: 0, max: Infinity },
        actualValue: actualDuration,
        confidence: 0,
      };
    }

    const deviation = (actualDuration - baseline.mean) / baseline.stddev;
    const isAnomaly = Math.abs(deviation) > deviationThreshold;

    return {
      isAnomaly,
      deviationScore: deviation,
      expectedRange: {
        min: baseline.mean - deviationThreshold * baseline.stddev,
        max: baseline.mean + deviationThreshold * baseline.stddev,
      },
      actualValue: actualDuration,
      confidence: baseline.confidence,
    };
  }

  getAdaptiveThreshold(
    agentType: string,
    taskType: string,
    staticDefault: number
  ): number {
    const baseline = this.getBaseline(agentType, taskType);

    if (!baseline || baseline.confidence < 0.5) {
      return staticDefault;
    }

    // Use mean + 2 standard deviations as threshold
    const adaptiveThreshold = baseline.mean + 2 * baseline.stddev;

    // Blend with static based on confidence
    return (
      baseline.confidence * adaptiveThreshold +
      (1 - baseline.confidence) * staticDefault
    );
  }

  private pruneExpired(): void {
    const cutoff = new Date();
    cutoff.setDate(cutoff.getDate() - this.windowDays);

    this.observations = this.observations.filter(o =>
      o.timestamp > cutoff
    );
  }

  private calculateMean(values: number[]): number {
    return values.reduce((a, b) => a + b, 0) / values.length;
  }

  private calculateStdDev(values: number[], mean: number): number {
    const squaredDiffs = values.map(v => Math.pow(v - mean, 2));
    const avgSquaredDiff = this.calculateMean(squaredDiffs);
    return Math.sqrt(avgSquaredDiff);
  }
}

interface HistoricalConfig {
  windowDays?: number;
  minSamplesForConfidence?: number;
}
```

---

## Integration with Detection Engine

```typescript
// In detection-engine.ts, update to use historical baseline

private getThreshold(agentType: string, taskType: string): number {
  const staticThreshold = TASK_DURATION_ESTIMATES[taskType] || 60_000;

  // Use adaptive threshold if historical data available
  return this.historicalBaseline.getAdaptiveThreshold(
    agentType,
    taskType,
    staticThreshold
  );
}
```

---

## Validation

```bash
npx tsc --noEmit agents/monitoring/historical-baseline.ts
npm test -- --grep "historical-baseline"
```
