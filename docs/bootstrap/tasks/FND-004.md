# FND-004: TypeScript Strict Mode Compliance

---

## Metadata

| Field          | Value               |
| -------------- | ------------------- |
| **Phase**      | 1 - Foundation      |
| **Depends On** | FND-003             |
| **Blocks**     | None (nice-to-have) |
| **Priority**   | P3                  |
| **Owner**      | Human + Claude Code |

---

## Summary

Enable TypeScript strict mode (`"strict": true`) and resolve all type errors. This improves code quality, catches bugs at compile time, and ensures type safety across the codebase.

---

## Context

### Why Strict Mode?

| Benefit                  | Description                                    |
| ------------------------ | ---------------------------------------------- |
| **Type Safety**          | Catch null/undefined errors at compile time    |
| **Better IDE Support**   | More accurate autocomplete and error detection |
| **Code Quality**         | Forces explicit typing decisions               |
| **Fewer Runtime Errors** | Many bugs caught before running                |

### Strict Mode Flags

When `"strict": true` is enabled, these flags are set:

| Flag                           | Effect                                    |
| ------------------------------ | ----------------------------------------- |
| `noImplicitAny`                | Error on implicit `any` types             |
| `strictNullChecks`             | Null/undefined must be handled explicitly |
| `strictFunctionTypes`          | Stricter function type checking           |
| `strictBindCallApply`          | Check bind, call, apply arguments         |
| `strictPropertyInitialization` | Class properties must be initialized      |
| `noImplicitThis`               | Error on implicit `this` types            |
| `alwaysStrict`                 | Parse in strict mode, emit "use strict"   |

---

## Requirements

1. **Enable Strict Mode**:
   - Update `tsconfig.json` with `"strict": true`
   - Keep `"skipLibCheck": true` for third-party types

2. **Fix Type Errors**:
   - Add explicit types where needed
   - Handle null/undefined cases
   - Initialize class properties
   - Remove implicit `any` types

3. **Type Refinement**:
   - Use type guards for narrowing
   - Add proper return types to functions
   - Use `unknown` instead of `any` where appropriate

4. **Gradual Adoption** (if needed):
   - Start with specific directories
   - Use `// @ts-ignore` sparingly (document why)
   - Track remaining errors

---

## Pass Criteria

**PASS** when ALL of the following are true:

| #   | Criterion            | How to Verify                   |
| --- | -------------------- | ------------------------------- |
| 1   | Strict mode enabled  | Check `tsconfig.json`           |
| 2   | No TypeScript errors | `npx tsc --noEmit` exits with 0 |
| 3   | Tests still pass     | `npm test` succeeds             |
| 4   | App runs correctly   | Manual smoke test               |

**FAIL** if any criterion is not met.

---

## Output Files

```
tsconfig.json                    <- Updated with strict: true
[various .ts files]              <- Type fixes applied
```

---

## Common Fixes

### Implicit Any

```typescript
// Before
function process(data) { ... }

// After
function process(data: ProcessData): Result { ... }
```

### Null Checks

```typescript
// Before
const user = getUser();
console.log(user.name);

// After
const user = getUser();
if (user) {
  console.log(user.name);
}
// Or: console.log(user?.name ?? 'Unknown');
```

### Class Property Initialization

```typescript
// Before
class Service {
  db: Database;
}

// After
class Service {
  db: Database;
  constructor(db: Database) {
    this.db = db;
  }
}
// Or: db!: Database; (if initialized elsewhere)
```

---

## Validation

```bash
# Check for TypeScript errors
npx tsc --noEmit

# Count remaining errors (if gradual)
npx tsc --noEmit 2>&1 | grep "error TS" | wc -l

# Run tests to ensure no regressions
npm test
```

---

## Next Steps

After completing: TypeScript codebase is fully type-safe. Proceed with test infrastructure setup (FND-005).
