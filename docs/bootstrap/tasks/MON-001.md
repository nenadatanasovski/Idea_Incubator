# MON-001: Monitoring Agent Core Architecture

---

## Metadata

| Field          | Value                                                                  |
| -------------- | ---------------------------------------------------------------------- |
| **Phase**      | 2 - Monitoring Agent                                                   |
| **Depends On** | ORC-001, ORC-002, WSK-001, WEB-001, WEB-002                            |
| **Blocks**     | MON-002, MON-003, MON-004, MON-005, MON-006, MON-007, MON-008, MON-009 |
| **Priority**   | P1                                                                     |
| **Owner**      | Human (then Build Agent)                                               |

---

## Summary

Implement the core architecture for the Monitoring Agent - the "soul" of the Vibe platform. This agent observes all other agents through both the Event Bus (primary) and Puppeteer MCP (UI validation), detects issues, and takes graduated actions.

---

## Context

The Monitoring Agent is foundational infrastructure, not just another worker agent. It must be online before any worker agents (Spec, Build, Validation, SIA) begin work. Every worker agent is monitored from day one.

### Why Hybrid Approach?

| Source        | Purpose                        | Characteristics                       |
| ------------- | ------------------------------ | ------------------------------------- |
| Event Bus     | Primary truth for agent state  | Fast (<10ms), typed, authoritative    |
| Puppeteer MCP | UI validation, user experience | Catches UI bugs, validates full stack |

When sources agree = high confidence. When they diverge = investigation trigger.

---

## Requirements

1. **Core Class Structure**:
   - `MonitoringAgent` main class
   - Lifecycle methods (start, stop, pause)
   - Configuration loading
   - Dependency injection for components

2. **Component Integration Points**:
   - Event Bus Listener (MON-002)
   - Puppeteer Observer (MON-003)
   - State Reconciler (MON-004)
   - Detection Engine (MON-005)
   - Response Escalator (MON-006)
   - Action Executor (MON-007)
   - Heartbeat Emitter (MON-008)

3. **Health States**:
   - HEALTHY: Both sources working
   - DEGRADED: One source down (continue with caution)
   - UNHEALTHY: Both down (pause all loops)
   - CRITICAL: Unhealthy > 5 minutes (terminate, alert human)

---

## Pass Criteria

**PASS** when ALL of the following are true:

| #   | Criterion               | How to Verify                                                                       |
| --- | ----------------------- | ----------------------------------------------------------------------------------- |
| 1   | Core file exists        | `test -f agents/monitoring/core.ts` returns 0                                       |
| 2   | Exports MonitoringAgent | `grep -q "export class MonitoringAgent" agents/monitoring/core.ts` returns 0        |
| 3   | Has start/stop methods  | `grep -q "start\|stop" agents/monitoring/core.ts` returns 0                         |
| 4   | Has 4 health states     | `grep -c "HEALTHY\|DEGRADED\|UNHEALTHY\|CRITICAL" agents/monitoring/core.ts` >= 4   |
| 5   | Integrates components   | `grep -q "EventBusListener\|PuppeteerObserver" agents/monitoring/core.ts` returns 0 |
| 6   | TypeScript compiles     | `npx tsc --noEmit agents/monitoring/core.ts` returns 0                              |
| 7   | Can instantiate         | Unit test creates instance without error                                            |

**FAIL** if any criterion is not met.

---

## Output Files

```
agents/monitoring/
├── core.ts              ← PRIMARY OUTPUT
├── types.ts             ← Shared types
└── config.ts            ← Configuration
```

---

## Code Template

```typescript
// agents/monitoring/core.ts

import { EventBusListener } from "./event-bus-listener";
import { PuppeteerObserver } from "./puppeteer-observer";
import { StateReconciler } from "./state-reconciler";
import { DetectionEngine } from "./detection-engine";
import { ResponseEscalator } from "./response-escalator";
import { ActionExecutor } from "./action-executor";
import { HeartbeatEmitter } from "./heartbeat-emitter";
import { MonitoringConfig, HealthState } from "./types";

export class MonitoringAgent {
  private config: MonitoringConfig;
  private healthState: HealthState = "HEALTHY";

  // Components
  private eventBusListener: EventBusListener;
  private puppeteerObserver: PuppeteerObserver;
  private stateReconciler: StateReconciler;
  private detectionEngine: DetectionEngine;
  private responseEscalator: ResponseEscalator;
  private actionExecutor: ActionExecutor;
  private heartbeatEmitter: HeartbeatEmitter;

  constructor(config: MonitoringConfig) {
    this.config = config;
    this.initializeComponents();
  }

  private initializeComponents(): void {
    this.eventBusListener = new EventBusListener(this.config.eventBus);
    this.puppeteerObserver = new PuppeteerObserver(this.config.puppeteer);
    this.stateReconciler = new StateReconciler();
    this.detectionEngine = new DetectionEngine(this.config.detection);
    this.responseEscalator = new ResponseEscalator();
    this.actionExecutor = new ActionExecutor(this.config.actions);
    this.heartbeatEmitter = new HeartbeatEmitter(this.config.heartbeat);
  }

  async start(): Promise<void> {
    // 1. Connect to event bus
    await this.eventBusListener.connect();

    // 2. Initialize Puppeteer
    await this.puppeteerObserver.initialize();

    // 3. Start heartbeat
    this.heartbeatEmitter.start();

    // 4. Begin observation loop
    this.startObservationLoop();
  }

  async stop(): Promise<void> {
    this.heartbeatEmitter.stop();
    await this.puppeteerObserver.close();
    await this.eventBusListener.disconnect();
  }

  getHealthState(): HealthState {
    return this.healthState;
  }

  private async startObservationLoop(): Promise<void> {
    // Main monitoring loop
    setInterval(async () => {
      await this.observe();
    }, this.config.observationInterval);
  }

  private async observe(): Promise<void> {
    // 1. Get state from both sources
    const eventBusState = this.eventBusListener.getCurrentState();
    const puppeteerState = await this.puppeteerObserver.captureState();

    // 2. Reconcile states
    const reconciled = this.stateReconciler.reconcile(
      eventBusState,
      puppeteerState,
    );

    // 3. Detect issues
    const issues = this.detectionEngine.detect(reconciled);

    // 4. Handle any detected issues
    for (const issue of issues) {
      const response = this.responseEscalator.getResponse(issue);
      await this.actionExecutor.execute(response, issue);
    }

    // 5. Update health state
    this.updateHealthState();
  }

  private updateHealthState(): void {
    const eventBusOk = this.eventBusListener.isConnected();
    const puppeteerOk = this.puppeteerObserver.isConnected();

    if (eventBusOk && puppeteerOk) {
      this.healthState = "HEALTHY";
    } else if (eventBusOk || puppeteerOk) {
      this.healthState = "DEGRADED";
    } else {
      this.healthState = "UNHEALTHY";
    }
  }
}
```

---

## Validation

```bash
# TypeScript compiles
npx tsc --noEmit agents/monitoring/core.ts

# Unit tests
npm test -- --grep "monitoring-agent"

# Integration test (requires infrastructure)
npm run test:integration -- --grep "monitoring"
```

---

## Next Steps

After completing: Implement each component (MON-002 through MON-009) following this architecture.
