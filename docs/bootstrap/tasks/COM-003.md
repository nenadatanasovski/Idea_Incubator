# COM-003: Chat ID Linking (User Verification)

---

## Metadata

| Field          | Value                     |
| -------------- | ------------------------- |
| **Phase**      | 0 - Communication Core    |
| **Depends On** | COM-001, COM-002, FND-002 |
| **Blocks**     | COM-004, COM-006          |
| **Priority**   | P1                        |
| **Owner**      | Build Agent               |

---

## Summary

Implement the chat ID linking system that connects the user's phone number (+61431366620) to their Telegram chat IDs for each bot. The user must start a conversation with each bot and verify their identity.

---

## Context

### Why Chat ID Linking?

Telegram bots can't initiate conversations. The user must message the bot first. Once they do, we capture their `chat_id` which is used for all future messages.

Since we have multiple bots, the user needs to start a conversation with each one. The chat_id may be the same across bots (for the same user), but we store it per-bot for flexibility.

### Verification Flow

```
User messages bot: /start
        │
        ▼
Bot sends verification code (6 digits)
        │
        ▼
User enters code (proves they own the phone number)
        │
        ▼
chat_id stored in database, linked to phone number
        │
        ▼
Bot confirms: "Linked! You'll receive notifications here."
```

---

## Requirements

1. **Chat ID Storage**:
   - Store in database (users table or dedicated table)
   - Link to phone number
   - Track per-bot chat IDs
   - Track verification status

2. **Verification Process**:
   - Generate 6-digit code
   - Send code via email (to configured PRIMARY_EMAIL)
   - User enters code in Telegram
   - Mark as verified on match

3. **Multi-Bot Linking**:
   - User can link all bots with single verification
   - Or verify each bot individually
   - Track which bots are linked

---

## Pass Criteria

**PASS** when ALL of the following are true:

| #   | Criterion                 | How to Verify                                                                     |
| --- | ------------------------- | --------------------------------------------------------------------------------- |
| 1   | File exists               | `test -f server/communication/chat-linker.ts` returns 0                           |
| 2   | Exports ChatLinker        | `grep -q "export class ChatLinker" server/communication/chat-linker.ts` returns 0 |
| 3   | Has linkChat method       | `grep -q "linkChat\|link(" server/communication/chat-linker.ts` returns 0         |
| 4   | Has verification          | `grep -q "verify\|code" server/communication/chat-linker.ts` returns 0            |
| 5   | Database migration exists | `test -f database/migrations/030_telegram_chat_links.sql` returns 0               |
| 6   | TypeScript compiles       | `npx tsc --noEmit server/communication/chat-linker.ts` returns 0                  |
| 7   | Unit tests pass           | `npm test -- --grep "chat-linker"` passes                                         |

**FAIL** if any criterion is not met.

---

## Output Files

```
server/communication/
└── chat-linker.ts

database/migrations/
└── 030_telegram_chat_links.sql
```

---

## Database Schema

```sql
-- database/migrations/030_telegram_chat_links.sql

CREATE TABLE telegram_chat_links (
  id TEXT PRIMARY KEY,
  phone_number TEXT NOT NULL,
  email TEXT,
  bot_type TEXT NOT NULL,  -- 'monitoring', 'spec', etc.
  chat_id TEXT NOT NULL,
  verified INTEGER DEFAULT 0,
  verification_code TEXT,
  verification_expires_at DATETIME,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  verified_at DATETIME,
  UNIQUE(phone_number, bot_type)
);

CREATE INDEX idx_chat_links_phone ON telegram_chat_links(phone_number);
CREATE INDEX idx_chat_links_chat_id ON telegram_chat_links(chat_id);
CREATE INDEX idx_chat_links_bot_type ON telegram_chat_links(bot_type);
```

---

## Code Template

```typescript
// server/communication/chat-linker.ts

import { Database } from "../../database/db";
import { EmailSender } from "./email-sender";
import { AgentType } from "./bot-registry";

interface ChatLink {
  id: string;
  phoneNumber: string;
  email: string | null;
  botType: AgentType;
  chatId: string;
  verified: boolean;
  verificationCode: string | null;
  verificationExpiresAt: Date | null;
  createdAt: Date;
  verifiedAt: Date | null;
}

interface LinkConfig {
  primaryPhone: string; // +61431366620
  primaryEmail: string; // your-email@example.com
  codeExpiryMinutes: number; // 30
}

export class ChatLinker {
  private db: Database;
  private emailSender: EmailSender;
  private config: LinkConfig;

  constructor(db: Database, emailSender: EmailSender, config: LinkConfig) {
    this.db = db;
    this.emailSender = emailSender;
    this.config = config;
  }

  async handleStartCommand(
    botType: AgentType,
    chatId: string,
  ): Promise<string> {
    // Check if already linked and verified
    const existing = await this.getLink(this.config.primaryPhone, botType);

    if (existing?.verified) {
      return `Already linked and verified! You'll receive ${botType} notifications here.`;
    }

    // Generate verification code
    const code = this.generateCode();
    const expiresAt = new Date(
      Date.now() + this.config.codeExpiryMinutes * 60 * 1000,
    );

    // Store pending link
    await this.storePendingLink({
      phoneNumber: this.config.primaryPhone,
      email: this.config.primaryEmail,
      botType,
      chatId,
      verificationCode: code,
      verificationExpiresAt: expiresAt,
    });

    // Send code via email
    await this.emailSender.send({
      to: this.config.primaryEmail,
      subject: `Vibe ${botType} Bot Verification Code`,
      text: `Your verification code is: ${code}\n\nEnter this code in Telegram to link your account.\n\nExpires in ${this.config.codeExpiryMinutes} minutes.`,
    });

    return `Verification code sent to ${this.maskEmail(this.config.primaryEmail)}.\n\nReply with the 6-digit code to complete linking.`;
  }

  async handleVerificationCode(
    botType: AgentType,
    chatId: string,
    code: string,
  ): Promise<{ success: boolean; message: string }> {
    const link = await this.getLinkByChatId(chatId, botType);

    if (!link) {
      return {
        success: false,
        message: "No pending verification. Send /start first.",
      };
    }

    if (link.verified) {
      return { success: false, message: "Already verified!" };
    }

    if (!link.verificationCode || !link.verificationExpiresAt) {
      return {
        success: false,
        message: "No verification code found. Send /start to get a new code.",
      };
    }

    if (new Date() > link.verificationExpiresAt) {
      return {
        success: false,
        message: "Code expired. Send /start to get a new code.",
      };
    }

    if (link.verificationCode !== code) {
      return { success: false, message: "Invalid code. Please try again." };
    }

    // Mark as verified
    await this.markVerified(link.id);

    // Offer to link other bots
    return {
      success: true,
      message: `Verified! You'll receive ${botType} notifications here.\n\nTo link other agent bots, message each one with /start.`,
    };
  }

  async getChatId(
    phoneNumber: string,
    botType: AgentType,
  ): Promise<string | null> {
    const link = await this.getLink(phoneNumber, botType);
    return link?.verified ? link.chatId : null;
  }

  async getVerifiedChatIds(
    phoneNumber: string,
  ): Promise<Map<AgentType, string>> {
    const links = await this.getAllLinks(phoneNumber);
    const result = new Map<AgentType, string>();

    for (const link of links) {
      if (link.verified) {
        result.set(link.botType as AgentType, link.chatId);
      }
    }

    return result;
  }

  async isLinked(phoneNumber: string, botType: AgentType): Promise<boolean> {
    const link = await this.getLink(phoneNumber, botType);
    return link?.verified ?? false;
  }

  async linkAllBots(phoneNumber: string, chatId: string): Promise<void> {
    // Link all bots with same chat ID (user verified once)
    const botTypes: AgentType[] = [
      "monitoring",
      "orchestrator",
      "spec",
      "build",
      "validation",
      "sia",
      "system",
    ];

    for (const botType of botTypes) {
      await this.storePendingLink({
        phoneNumber,
        email: this.config.primaryEmail,
        botType,
        chatId,
        verificationCode: null,
        verificationExpiresAt: null,
      });
      await this.markVerifiedByPhone(phoneNumber, botType);
    }
  }

  private generateCode(): string {
    return Math.floor(100000 + Math.random() * 900000).toString();
  }

  private maskEmail(email: string): string {
    const [local, domain] = email.split("@");
    return `${local.substring(0, 2)}***@${domain}`;
  }

  // Database methods
  private async getLink(
    phoneNumber: string,
    botType: AgentType,
  ): Promise<ChatLink | null> {
    // Implementation
  }

  private async getLinkByChatId(
    chatId: string,
    botType: AgentType,
  ): Promise<ChatLink | null> {
    // Implementation
  }

  private async getAllLinks(phoneNumber: string): Promise<ChatLink[]> {
    // Implementation
  }

  private async storePendingLink(link: Partial<ChatLink>): Promise<void> {
    // Implementation
  }

  private async markVerified(linkId: string): Promise<void> {
    // Implementation
  }

  private async markVerifiedByPhone(
    phoneNumber: string,
    botType: AgentType,
  ): Promise<void> {
    // Implementation
  }
}
```

---

## Validation

```bash
npm run migrate
npx tsc --noEmit server/communication/chat-linker.ts
npm test -- --grep "chat-linker"
```
