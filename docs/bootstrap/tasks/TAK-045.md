# TAK-045: Retrospective Learner Service

---

## Metadata

| Field          | Value                   |
| -------------- | ----------------------- |
| **Phase**      | Additional Capabilities |
| **Depends On** | TAK-016                 |
| **Blocks**     | None                    |
| **Priority**   | P3                      |
| **Owner**      | Build Agent             |

---

## Summary

Implement a RetrospectiveLearner service that analyzes completed tasks to improve estimates, predictions, and recommendations over time.

---

## Requirements

1. **Estimate Comparison**:
   - Compare estimated vs actual effort
   - Track accuracy by category
   - Identify systematic over/under estimation

2. **Blocker Analysis**:
   - Track common blockers by category
   - Identify recurring patterns
   - Suggest preventive measures

3. **Classification Improvement**:
   - Track classification accuracy
   - Learn from corrections
   - Update classification rules

4. **SIA Integration**:
   - Generate insights for Self-Improvement Agent
   - Propose system improvements
   - Track improvement effectiveness

---

## Pass Criteria

**PASS** when ALL of the following are true:

| #   | Criterion          | How to Verify                                                                              |
| --- | ------------------ | ------------------------------------------------------------------------------------------ |
| 1   | File exists        | `test -f server/services/task-agent/retrospective-learner.ts` returns 0                    |
| 2   | Has analyze method | `grep -q "analyze\|Analyze" server/services/task-agent/retrospective-learner.ts` returns 0 |
| 3   | Has learning logic | `grep -q "learn\|Learn" server/services/task-agent/retrospective-learner.ts` returns 0     |
| 4   | Compiles           | `npx tsc --noEmit server/services/task-agent/retrospective-learner.ts` passes              |

**FAIL** if any criterion is not met.

---

## Output Files

```
server/services/task-agent/
└── retrospective-learner.ts
```

---

## Code Template

```typescript
// Retrospective Learner Service
// Learns from completed tasks to improve future predictions

import { db } from "../../database";

interface EstimateAnalysis {
  category: string;
  averageEstimate: number;
  averageActual: number;
  accuracyRatio: number; // actual/estimate
  sampleSize: number;
}

interface BlockerPattern {
  category: string;
  blockerType: string;
  frequency: number;
  avgResolutionTime: number; // minutes
  preventiveMeasures: string[];
}

interface LearningInsight {
  type:
    | "estimate_calibration"
    | "blocker_prevention"
    | "classification_improvement"
    | "process_improvement";
  description: string;
  confidence: number;
  suggestedAction: string;
  data: Record<string, any>;
}

export class RetrospectiveLearner {
  private analysisWindow = 90; // days

  async analyzeEstimateAccuracy(): Promise<EstimateAnalysis[]> {
    const results = db
      .prepare(
        `
      SELECT
        category,
        AVG(CAST(REPLACE(REPLACE(estimated_effort, 'h', ''), 'm', '') AS INTEGER)) as avg_estimate,
        AVG(actual_effort_minutes) as avg_actual,
        COUNT(*) as sample_size
      FROM tasks
      WHERE status = 'completed'
        AND estimated_effort IS NOT NULL
        AND actual_effort_minutes IS NOT NULL
        AND completed_at > datetime('now', '-${this.analysisWindow} days')
      GROUP BY category
      HAVING sample_size >= 5
    `,
      )
      .all() as any[];

    return results.map((r) => ({
      category: r.category,
      averageEstimate: r.avg_estimate * 60, // Convert to minutes
      averageActual: r.avg_actual,
      accuracyRatio: r.avg_actual / (r.avg_estimate * 60),
      sampleSize: r.sample_size,
    }));
  }

  async analyzeBlockerPatterns(): Promise<BlockerPattern[]> {
    const results = db
      .prepare(
        `
      SELECT
        t.category,
        tb.block_type,
        COUNT(*) as frequency,
        AVG(
          CAST((julianday(tb.resolved_at) - julianday(tb.created_at)) * 24 * 60 AS INTEGER)
        ) as avg_resolution_minutes
      FROM task_blocks tb
      JOIN tasks t ON tb.task_id = t.id
      WHERE tb.resolved_at IS NOT NULL
        AND tb.created_at > datetime('now', '-${this.analysisWindow} days')
      GROUP BY t.category, tb.block_type
      HAVING frequency >= 3
      ORDER BY frequency DESC
    `,
      )
      .all() as any[];

    return results.map((r) => ({
      category: r.category,
      blockerType: r.block_type,
      frequency: r.frequency,
      avgResolutionTime: r.avg_resolution_minutes,
      preventiveMeasures: this.getSuggestedPrevention(r.block_type),
    }));
  }

  private getSuggestedPrevention(blockerType: string): string[] {
    const preventionMap: Record<string, string[]> = {
      validation: [
        "Add acceptance criteria before starting",
        "Run validation check early",
        "Include test cases in task definition",
      ],
      dependency: [
        "Review dependency chain before starting",
        "Prioritize blockers first",
        "Consider parallel work streams",
      ],
      ambiguous: [
        "Clarify requirements with stakeholder",
        "Add specific acceptance criteria",
        "Break down vague tasks",
      ],
      missing_tests: [
        "Generate test scaffolds during task creation",
        "Review test requirements by category",
        "Add test generation to workflow",
      ],
    };

    return preventionMap[blockerType] || ["Review task definition carefully"];
  }

  async generateInsights(): Promise<LearningInsight[]> {
    const insights: LearningInsight[] = [];

    // Analyze estimate accuracy
    const estimates = await this.analyzeEstimateAccuracy();
    for (const est of estimates) {
      if (est.accuracyRatio < 0.7 || est.accuracyRatio > 1.5) {
        insights.push({
          type: "estimate_calibration",
          description: `${est.category} tasks are ${est.accuracyRatio < 1 ? "over" : "under"}estimated`,
          confidence: Math.min(est.sampleSize / 20, 1),
          suggestedAction: `Multiply ${est.category} estimates by ${(1 / est.accuracyRatio).toFixed(2)}`,
          data: est,
        });
      }
    }

    // Analyze blocker patterns
    const blockers = await this.analyzeBlockerPatterns();
    for (const blocker of blockers) {
      if (blocker.frequency >= 5) {
        insights.push({
          type: "blocker_prevention",
          description: `${blocker.blockerType} blocks are common for ${blocker.category} tasks`,
          confidence: Math.min(blocker.frequency / 10, 1),
          suggestedAction: blocker.preventiveMeasures[0],
          data: blocker,
        });
      }
    }

    // Check for process improvements
    const completionRate = await this.analyzeCompletionRate();
    if (completionRate < 0.7) {
      insights.push({
        type: "process_improvement",
        description: `Task completion rate is ${(completionRate * 100).toFixed(0)}%`,
        confidence: 0.8,
        suggestedAction: "Review task breakdown and validation processes",
        data: { completionRate },
      });
    }

    return insights;
  }

  private async analyzeCompletionRate(): Promise<number> {
    const result = db
      .prepare(
        `
      SELECT
        CAST(SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) AS FLOAT) / COUNT(*) as rate
      FROM tasks
      WHERE created_at > datetime('now', '-${this.analysisWindow} days')
        AND status IN ('completed', 'failed', 'cancelled')
    `,
      )
      .get() as { rate: number };

    return result.rate || 0;
  }

  async publishToSIA(insights: LearningInsight[]): Promise<void> {
    // Store high-confidence insights in knowledge base
    for (const insight of insights) {
      if (insight.confidence >= 0.7) {
        db.prepare(
          `
          INSERT INTO knowledge_entries (id, type, content, confidence, source, created_at)
          VALUES (?, ?, ?, ?, 'retrospective-learner', datetime('now'))
        `,
        ).run(
          `kb-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
          insight.type,
          JSON.stringify(insight),
          insight.confidence,
        );
      }
    }

    // Emit event for SIA
    // TODO: Use CommunicationHub to publish
  }

  async runDailyAnalysis(): Promise<LearningInsight[]> {
    const insights = await this.generateInsights();
    await this.publishToSIA(insights);
    return insights;
  }
}

export default RetrospectiveLearner;
```

---

## Gotchas

- Need sufficient sample size before drawing conclusions
- Accuracy may vary by task complexity, not just category
- Historical data may not reflect current team capabilities

---

## Validation

```bash
# Type check
npx tsc --noEmit server/services/task-agent/retrospective-learner.ts

# Run unit tests
npm test -- --grep "retrospective-learner"
```

---

## Next Steps

After completing this task:

1. Schedule daily analysis job
2. Build dashboard for viewing insights
3. Connect to SIA for automated improvements
