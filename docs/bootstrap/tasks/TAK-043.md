# TAK-043: Workload Balancer Service

---

## Metadata

| Field | Value |
|-------|-------|
| **Phase** | Additional Capabilities |
| **Depends On** | TAK-016 |
| **Blocks** | None |
| **Priority** | P3 |
| **Owner** | Build Agent |

---

## Summary

Implement a WorkloadBalancer service that optimally distributes tasks across available agents based on capacity, specialization, and current load.

---

## Requirements

1. **Agent Capacity Tracking**:
   - Track each agent's current task count
   - Monitor agent health and availability
   - Calculate remaining capacity

2. **Task Complexity Assessment**:
   - Estimate task effort based on category and description
   - Factor in historical completion times
   - Consider dependency complexity

3. **Optimal Assignment**:
   - Match tasks to agent specializations
   - Balance load across agents
   - Optimize for throughput vs latency

4. **Overload Prevention**:
   - Set maximum concurrent tasks per agent
   - Queue tasks when all agents busy
   - Alert on sustained high load

---

## Pass Criteria

**PASS** when ALL of the following are true:

| # | Criterion | How to Verify |
|---|-----------|---------------|
| 1 | File exists | `test -f server/services/task-agent/workload-balancer.ts` returns 0 |
| 2 | Has balance method | `grep -q "balance\|Balance" server/services/task-agent/workload-balancer.ts` returns 0 |
| 3 | Has capacity tracking | `grep -q "capacity\|Capacity" server/services/task-agent/workload-balancer.ts` returns 0 |
| 4 | Compiles | `npx tsc --noEmit server/services/task-agent/workload-balancer.ts` passes |

**FAIL** if any criterion is not met.

---

## Output Files

```
server/services/task-agent/
└── workload-balancer.ts
```

---

## Code Template

```typescript
// Workload Balancer Service
// Distributes tasks optimally across agents

import { db } from '../../database';

interface AgentCapacity {
  agentId: string;
  agentType: string;
  maxConcurrent: number;
  currentTasks: number;
  specializations: string[];  // Task categories agent excels at
  healthScore: number;  // 0-1
  lastHeartbeat: string;
}

interface TaskAssignment {
  taskId: string;
  agentId: string;
  reason: string;
  estimatedDuration: number;  // minutes
}

interface LoadMetrics {
  totalAgents: number;
  activeAgents: number;
  totalCapacity: number;
  usedCapacity: number;
  utilizationRate: number;
  queuedTasks: number;
}

export class WorkloadBalancer {
  private agentCapacities: Map<string, AgentCapacity> = new Map();
  private maxConcurrentDefault = 5;

  constructor() {
    this.loadAgentCapacities();
  }

  async loadAgentCapacities(): Promise<void> {
    const agents = db.prepare(`
      SELECT id, type, status, current_task_id, last_heartbeat
      FROM agents
      WHERE status IN ('idle', 'busy')
    `).all();

    for (const agent of agents as any[]) {
      const currentTasks = db.prepare(`
        SELECT COUNT(*) as count FROM tasks
        WHERE assigned_agent = ? AND status = 'in_progress'
      `).get(agent.id) as { count: number };

      this.agentCapacities.set(agent.id, {
        agentId: agent.id,
        agentType: agent.type,
        maxConcurrent: this.maxConcurrentDefault,
        currentTasks: currentTasks.count,
        specializations: this.getSpecializations(agent.type),
        healthScore: this.calculateHealthScore(agent),
        lastHeartbeat: agent.last_heartbeat
      });
    }
  }

  private getSpecializations(agentType: string): string[] {
    const specializationMap: Record<string, string[]> = {
      'build-agent': ['feature', 'bug', 'infrastructure', 'migration'],
      'spec-agent': ['documentation', 'technical_debt', 'refactoring'],
      'validation-agent': ['testing', 'security', 'performance'],
      'ux-agent': ['ux_design', 'improvement'],
    };
    return specializationMap[agentType] || [];
  }

  private calculateHealthScore(agent: any): number {
    if (!agent.last_heartbeat) return 0;

    const lastHeartbeat = new Date(agent.last_heartbeat);
    const now = new Date();
    const minutesSince = (now.getTime() - lastHeartbeat.getTime()) / (1000 * 60);

    // Health degrades as time since heartbeat increases
    if (minutesSince < 1) return 1;
    if (minutesSince < 5) return 0.8;
    if (minutesSince < 15) return 0.5;
    return 0.2;
  }

  async assignTask(taskId: string): Promise<TaskAssignment | null> {
    const task = db.prepare('SELECT * FROM tasks WHERE id = ?').get(taskId) as any;
    if (!task) return null;

    // Find best available agent
    let bestAgent: AgentCapacity | null = null;
    let bestScore = -1;

    for (const [_, capacity] of this.agentCapacities) {
      // Skip agents at capacity
      if (capacity.currentTasks >= capacity.maxConcurrent) continue;

      // Skip unhealthy agents
      if (capacity.healthScore < 0.5) continue;

      // Calculate assignment score
      let score = capacity.healthScore;

      // Bonus for specialization match
      if (capacity.specializations.includes(task.category)) {
        score += 0.3;
      }

      // Bonus for lower current load
      const loadRatio = capacity.currentTasks / capacity.maxConcurrent;
      score += (1 - loadRatio) * 0.2;

      if (score > bestScore) {
        bestScore = score;
        bestAgent = capacity;
      }
    }

    if (!bestAgent) {
      // No available agents, queue the task
      return null;
    }

    return {
      taskId,
      agentId: bestAgent.agentId,
      reason: `Best match: ${bestAgent.agentType} (score: ${bestScore.toFixed(2)})`,
      estimatedDuration: this.estimateTaskDuration(task)
    };
  }

  private estimateTaskDuration(task: any): number {
    // Base estimates by category
    const baseEstimates: Record<string, number> = {
      'feature': 120,
      'bug': 60,
      'improvement': 90,
      'documentation': 30,
      'refactoring': 90,
      'testing': 60,
    };

    return baseEstimates[task.category] || 60;
  }

  async getLoadMetrics(): Promise<LoadMetrics> {
    let totalCapacity = 0;
    let usedCapacity = 0;
    let activeAgents = 0;

    for (const [_, capacity] of this.agentCapacities) {
      if (capacity.healthScore >= 0.5) {
        activeAgents++;
        totalCapacity += capacity.maxConcurrent;
        usedCapacity += capacity.currentTasks;
      }
    }

    const queuedTasks = db.prepare(`
      SELECT COUNT(*) as count FROM tasks
      WHERE status = 'pending' AND assigned_agent IS NULL
    `).get() as { count: number };

    return {
      totalAgents: this.agentCapacities.size,
      activeAgents,
      totalCapacity,
      usedCapacity,
      utilizationRate: totalCapacity > 0 ? usedCapacity / totalCapacity : 0,
      queuedTasks: queuedTasks.count
    };
  }

  async rebalance(): Promise<TaskAssignment[]> {
    const assignments: TaskAssignment[] = [];

    // Get all pending unassigned tasks
    const pendingTasks = db.prepare(`
      SELECT id FROM tasks
      WHERE status = 'pending' AND assigned_agent IS NULL
      ORDER BY priority DESC
      LIMIT 10
    `).all() as { id: string }[];

    for (const task of pendingTasks) {
      const assignment = await this.assignTask(task.id);
      if (assignment) {
        assignments.push(assignment);

        // Update capacity tracking
        const capacity = this.agentCapacities.get(assignment.agentId);
        if (capacity) {
          capacity.currentTasks++;
        }
      }
    }

    return assignments;
  }
}

export default WorkloadBalancer;
```

---

## Gotchas

- Agent health checks depend on heartbeat frequency
- Don't reassign tasks that are already in progress
- Consider time zones and working hours for human agents

---

## Validation

```bash
# Type check
npx tsc --noEmit server/services/task-agent/workload-balancer.ts

# Run unit tests
npm test -- --grep "workload-balancer"
```

---

## Next Steps

After completing this task:
1. Integrate with TaskAgent for automatic assignment
2. Add dashboard visualization of load metrics
3. Implement alerts for high utilization
