# MON-004: State Reconciler

---

## Metadata

| Field          | Value                    |
| -------------- | ------------------------ |
| **Phase**      | 2 - Monitoring Agent     |
| **Depends On** | MON-002, MON-003         |
| **Blocks**     | MON-005                  |
| **Priority**   | P1                       |
| **Owner**      | Human (then Build Agent) |

---

## Summary

Implement the State Reconciler that compares Event Bus and Puppeteer observations, detects divergence, and builds confidence scores for decision-making.

---

## Requirements

1. **State Comparison**:
   - Match agents by ID across sources
   - Compare status values
   - Compare task descriptions
   - Track comparison timestamps

2. **Divergence Detection**:
   - Event Bus says X, UI shows Y → divergence
   - Flag as potential UI bug
   - Flag as potential stale WebSocket
   - Calculate staleness duration

3. **Confidence Scoring**:
   - Sources agree → high confidence
   - Sources diverge → low confidence
   - Factor in observation age
   - Factor in historical accuracy

---

## Pass Criteria

**PASS** when ALL of the following are true:

| #   | Criterion               | How to Verify                                                                            |
| --- | ----------------------- | ---------------------------------------------------------------------------------------- |
| 1   | File exists             | `test -f agents/monitoring/state-reconciler.ts` returns 0                                |
| 2   | Exports StateReconciler | `grep -q "export class StateReconciler" agents/monitoring/state-reconciler.ts` returns 0 |
| 3   | Has reconcile method    | `grep -q "reconcile(" agents/monitoring/state-reconciler.ts` returns 0                   |
| 4   | Detects divergence      | `grep -q "divergence\|Divergence" agents/monitoring/state-reconciler.ts` returns 0       |
| 5   | Calculates confidence   | `grep -q "confidence" agents/monitoring/state-reconciler.ts` returns 0                   |
| 6   | TypeScript compiles     | `npx tsc --noEmit agents/monitoring/state-reconciler.ts` returns 0                       |
| 7   | Unit tests pass         | `npm test -- --grep "state-reconciler"` passes                                           |

**FAIL** if any criterion is not met.

---

## Output Files

```
agents/monitoring/
└── state-reconciler.ts
```

---

## Code Template

```typescript
// agents/monitoring/state-reconciler.ts

import { AgentState } from "./event-bus-listener";
import { UIState, UIAgentState } from "./puppeteer-observer";

export interface ReconciledAgent {
  agentId: string;
  eventBusState?: AgentState;
  uiState?: UIAgentState;
  agreement: "full" | "partial" | "divergent" | "missing_source";
  confidence: number; // 0-1
  divergences: Divergence[];
}

export interface Divergence {
  field: string;
  eventBusValue: any;
  uiValue: any;
  severity: "info" | "warning" | "error";
  possibleCause: "ui_bug" | "stale_websocket" | "timing" | "unknown";
}

export interface ReconciledState {
  agents: ReconciledAgent[];
  overallConfidence: number;
  divergenceCount: number;
  reconciledAt: Date;
}

export class StateReconciler {
  reconcile(
    eventBusState: Map<string, AgentState>,
    uiState: UIState,
  ): ReconciledState {
    const agents: ReconciledAgent[] = [];

    // Get all unique agent IDs from both sources
    const allAgentIds = new Set([
      ...eventBusState.keys(),
      ...uiState.agents.map((a) => a.agentId),
    ]);

    for (const agentId of allAgentIds) {
      const ebState = eventBusState.get(agentId);
      const uiAgentState = uiState.agents.find((a) => a.agentId === agentId);

      const reconciled = this.reconcileAgent(agentId, ebState, uiAgentState);
      agents.push(reconciled);
    }

    const divergenceCount = agents.reduce(
      (sum, a) => sum + a.divergences.length,
      0,
    );
    const overallConfidence =
      agents.reduce((sum, a) => sum + a.confidence, 0) / agents.length;

    return {
      agents,
      overallConfidence,
      divergenceCount,
      reconciledAt: new Date(),
    };
  }

  private reconcileAgent(
    agentId: string,
    ebState?: AgentState,
    uiState?: UIAgentState,
  ): ReconciledAgent {
    const divergences: Divergence[] = [];

    // Missing source check
    if (!ebState && !uiState) {
      return {
        agentId,
        agreement: "missing_source",
        confidence: 0,
        divergences: [],
      };
    }

    if (!ebState || !uiState) {
      return {
        agentId,
        eventBusState: ebState,
        uiState,
        agreement: "missing_source",
        confidence: 0.3, // Partial confidence with one source
        divergences: [
          {
            field: "presence",
            eventBusValue: !!ebState,
            uiValue: !!uiState,
            severity: "warning",
            possibleCause: "timing",
          },
        ],
      };
    }

    // Compare status
    if (this.statusMatches(ebState.status, uiState.displayedStatus)) {
      // Agreement
    } else {
      divergences.push({
        field: "status",
        eventBusValue: ebState.status,
        uiValue: uiState.displayedStatus,
        severity: "warning",
        possibleCause: this.diagnoseDivergence(ebState, uiState),
      });
    }

    // Compare current task
    if (ebState.currentTask !== uiState.displayedTask) {
      divergences.push({
        field: "currentTask",
        eventBusValue: ebState.currentTask,
        uiValue: uiState.displayedTask,
        severity: "info",
        possibleCause: "timing",
      });
    }

    const agreement =
      divergences.length === 0
        ? "full"
        : divergences.every((d) => d.severity === "info")
          ? "partial"
          : "divergent";

    const confidence = this.calculateConfidence(divergences, ebState, uiState);

    return {
      agentId,
      eventBusState: ebState,
      uiState,
      agreement,
      confidence,
      divergences,
    };
  }

  private statusMatches(ebStatus: string, uiStatus: string): boolean {
    // Normalize and compare (UI might show "Working" vs event bus "working")
    return ebStatus.toLowerCase() === uiStatus.toLowerCase();
  }

  private diagnoseDivergence(
    eb: AgentState,
    ui: UIAgentState,
  ): Divergence["possibleCause"] {
    const ebAge = Date.now() - eb.lastActivity.getTime();
    const uiAge = Date.now() - ui.capturedAt.getTime();

    // If UI capture is much newer, Event Bus might be stale
    if (uiAge < ebAge - 5000) return "stale_websocket";

    // If Event Bus is newer, might be timing
    if (ebAge < uiAge - 2000) return "timing";

    // Otherwise likely a UI bug
    return "ui_bug";
  }

  private calculateConfidence(
    divergences: Divergence[],
    eb: AgentState,
    ui: UIAgentState,
  ): number {
    let confidence = 1.0;

    for (const d of divergences) {
      if (d.severity === "error") confidence -= 0.4;
      if (d.severity === "warning") confidence -= 0.2;
      if (d.severity === "info") confidence -= 0.05;
    }

    return Math.max(0, confidence);
  }
}
```

---

## Validation

```bash
npx tsc --noEmit agents/monitoring/state-reconciler.ts
npm test -- --grep "state-reconciler"
```
