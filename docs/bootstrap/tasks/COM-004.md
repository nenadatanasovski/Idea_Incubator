# COM-004: Telegram Message Sender

---

## Metadata

| Field | Value |
|-------|-------|
| **Phase** | 0 - Communication Core |
| **Depends On** | COM-002, COM-003 |
| **Blocks** | COM-006, COM-010 |
| **Priority** | P1 |
| **Owner** | Build Agent |

---

## Summary

Implement the Telegram message sender that routes messages to the correct bot based on agent type and delivers them to the linked chat ID.

---

## Requirements

1. **Message Sending**:
   - Send text messages with Markdown formatting
   - Send messages with inline keyboard buttons
   - Handle rate limiting (Telegram limits: 30 msg/sec to same chat)
   - Retry on failure with exponential backoff

2. **Bot Routing**:
   - Use BotRegistry to get correct bot for agent
   - Fall back to system bot if agent's bot unavailable
   - Log all messages sent

3. **Message Queue**:
   - Queue messages if rate limited
   - Process queue with delays
   - Persist queue for crash recovery

---

## Pass Criteria

**PASS** when ALL of the following are true:

| # | Criterion | How to Verify |
|---|-----------|---------------|
| 1 | File exists | `test -f server/communication/telegram-sender.ts` returns 0 |
| 2 | Exports TelegramSender | `grep -q "export class TelegramSender" server/communication/telegram-sender.ts` returns 0 |
| 3 | Has sendMessage method | `grep -q "sendMessage(" server/communication/telegram-sender.ts` returns 0 |
| 4 | Has sendWithButtons method | `grep -q "sendWithButtons\|InlineKeyboard" server/communication/telegram-sender.ts` returns 0 |
| 5 | Has retry logic | `grep -q "retry\|backoff" server/communication/telegram-sender.ts` returns 0 |
| 6 | TypeScript compiles | `npx tsc --noEmit server/communication/telegram-sender.ts` returns 0 |
| 7 | Unit tests pass | `npm test -- --grep "telegram-sender"` passes |

**FAIL** if any criterion is not met.

---

## Output Files

```
server/communication/
‚îî‚îÄ‚îÄ telegram-sender.ts
```

---

## Code Template

```typescript
// server/communication/telegram-sender.ts

import { BotRegistry, AgentType, RegisteredBot } from './bot-registry';
import { ChatLinker } from './chat-linker';

interface InlineButton {
  text: string;
  callbackData: string;
}

interface SendOptions {
  agentType: AgentType;
  text: string;
  parseMode?: 'Markdown' | 'HTML';
  buttons?: InlineButton[][];
  replyToMessageId?: number;
}

interface SendResult {
  success: boolean;
  messageId?: number;
  error?: string;
  usedFallback?: boolean;
}

export class TelegramSender {
  private botRegistry: BotRegistry;
  private chatLinker: ChatLinker;
  private primaryPhone: string;
  private messageQueue: SendOptions[] = [];
  private processing: boolean = false;

  constructor(
    botRegistry: BotRegistry,
    chatLinker: ChatLinker,
    primaryPhone: string
  ) {
    this.botRegistry = botRegistry;
    this.chatLinker = chatLinker;
    this.primaryPhone = primaryPhone;
  }

  async sendMessage(options: SendOptions): Promise<SendResult> {
    const bot = this.botRegistry.getBot(options.agentType);

    if (!bot) {
      return { success: false, error: 'No bot available' };
    }

    const chatId = await this.chatLinker.getChatId(this.primaryPhone, options.agentType);

    if (!chatId) {
      // Try system bot as fallback
      const systemChatId = await this.chatLinker.getChatId(this.primaryPhone, 'system');
      if (systemChatId) {
        const systemBot = this.botRegistry.getBot('system');
        if (systemBot) {
          const result = await this.doSend(systemBot, systemChatId, options);
          return { ...result, usedFallback: true };
        }
      }
      return { success: false, error: 'No linked chat ID' };
    }

    return this.doSend(bot, chatId, options);
  }

  async sendWithButtons(
    agentType: AgentType,
    text: string,
    buttons: InlineButton[][]
  ): Promise<SendResult> {
    return this.sendMessage({
      agentType,
      text,
      parseMode: 'Markdown',
      buttons,
    });
  }

  async sendQuestion(
    agentType: AgentType,
    questionId: string,
    questionText: string,
    options: { label: string; action: string }[]
  ): Promise<SendResult> {
    const buttons: InlineButton[][] = options.map(opt => [{
      text: opt.label,
      callbackData: `answer:${questionId}:${opt.action}`,
    }]);

    // Add "Other" option
    buttons.push([{
      text: 'Other (type reply)',
      callbackData: `answer:${questionId}:other`,
    }]);

    return this.sendWithButtons(agentType, questionText, buttons);
  }

  private async doSend(
    bot: RegisteredBot,
    chatId: string,
    options: SendOptions
  ): Promise<SendResult> {
    const url = `https://api.telegram.org/bot${bot.token}/sendMessage`;

    const body: any = {
      chat_id: chatId,
      text: options.text,
      parse_mode: options.parseMode || 'Markdown',
    };

    if (options.buttons) {
      body.reply_markup = {
        inline_keyboard: options.buttons.map(row =>
          row.map(btn => ({
            text: btn.text,
            callback_data: btn.callbackData,
          }))
        ),
      };
    }

    if (options.replyToMessageId) {
      body.reply_to_message_id = options.replyToMessageId;
    }

    return this.sendWithRetry(url, body);
  }

  private async sendWithRetry(url: string, body: any, attempt: number = 1): Promise<SendResult> {
    const maxAttempts = 3;
    const baseDelay = 1000;

    try {
      const response = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      });

      const data = await response.json();

      if (data.ok) {
        return { success: true, messageId: data.result.message_id };
      }

      // Rate limited
      if (data.error_code === 429) {
        const retryAfter = data.parameters?.retry_after || 30;
        if (attempt < maxAttempts) {
          await this.delay(retryAfter * 1000);
          return this.sendWithRetry(url, body, attempt + 1);
        }
      }

      return { success: false, error: data.description };
    } catch (error) {
      if (attempt < maxAttempts) {
        await this.delay(baseDelay * Math.pow(2, attempt - 1));
        return this.sendWithRetry(url, body, attempt + 1);
      }
      return { success: false, error: (error as Error).message };
    }
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

---

## Message Formatting

```typescript
// Example message formats

// Alert (concise)
const alertMessage = `
‚ö†Ô∏è *Alert from Monitoring*

Agent \`spec-agent-123\` has been idle for 5 minutes.

_No action required._
`;

// Question with buttons
const questionMessage = `
üî¥ *Blocking Question*

Which authentication approach should I use?

*Option A: JWT Tokens*
‚Ä¢ Stateless, scales easily
‚Ä¢ Can't invalidate without blacklist

*Option B: Server Sessions*
‚Ä¢ Easy invalidation
‚Ä¢ Requires session store

_Blocking: spec-agent-123_
`;

// Approval request (detailed)
const approvalMessage = `
üö® *Approval Required*

I want to *KILL* agent \`build-agent-456\`.

*Reason:* Agent has failed 5 consecutive tasks with same error.

*Error:* \`TypeError: Cannot read property 'id' of undefined\`

*History:*
‚Ä¢ 10:15 - Task failed
‚Ä¢ 10:18 - Task failed (retry 1)
‚Ä¢ 10:21 - Task failed (retry 2)
‚Ä¢ 10:24 - Task failed (retry 3)
‚Ä¢ 10:27 - Task failed (retry 4)

*This action requires manual restart.*
`;
```

---

## Validation

```bash
npx tsc --noEmit server/communication/telegram-sender.ts
npm test -- --grep "telegram-sender"
```
