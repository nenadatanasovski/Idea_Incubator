# COM-012: /summary Command (Monitoring Agent Summary)

---

## Metadata

| Field          | Value                     |
| -------------- | ------------------------- |
| **Phase**      | 0 - Communication Core    |
| **Depends On** | COM-005, COM-007, MON-001 |
| **Blocks**     | None                      |
| **Priority**   | P2                        |
| **Owner**      | Build Agent               |

---

## Summary

Implement the `/summary` command handler that requests a summary from the Monitoring Agent and delivers it via Telegram.

---

## Context

The user can send `/summary` to any bot to get a status report. The request is routed to the Monitoring Agent, which compiles:

- Current agent statuses
- Recent activity (configurable time window)
- Pending questions
- Issues detected

---

## Requirements

1. **Command Handling**:
   - Listen for `/summary` on all bots
   - Optional time parameter: `/summary 2h` for last 2 hours
   - Route request to Monitoring Agent

2. **Summary Content**:
   - Agent statuses (working/idle/blocked/error)
   - Recent activity count and highlights
   - Pending questions count and oldest
   - Issues detected in time window

3. **Formatting**:
   - Clean, readable Telegram message
   - Use emojis for status indicators
   - Truncate if too long

4. **Response Delivery**:
   - Send summary via same bot that received command
   - Handle Monitoring Agent unavailable

---

## Pass Criteria

**PASS** when ALL of the following are true:

| #   | Criterion                | How to Verify                                                                                     |
| --- | ------------------------ | ------------------------------------------------------------------------------------------------- |
| 1   | File exists              | `test -f server/communication/summary-handler.ts` returns 0                                       |
| 2   | Exports SummaryHandler   | `grep -q "export class SummaryHandler" server/communication/summary-handler.ts` returns 0         |
| 3   | Has handleSummaryCommand | `grep -q "handleSummaryCommand\|handleSummary" server/communication/summary-handler.ts` returns 0 |
| 4   | Builds summary message   | `grep -q "buildSummary\|formatSummary" server/communication/summary-handler.ts` returns 0         |
| 5   | TypeScript compiles      | `npx tsc --noEmit server/communication/summary-handler.ts` returns 0                              |
| 6   | Unit tests pass          | `npm test -- --grep "summary-handler"` passes                                                     |

**FAIL** if any criterion is not met.

---

## Output Files

```
server/communication/
‚îî‚îÄ‚îÄ summary-handler.ts
```

---

## Code Template

```typescript
// server/communication/summary-handler.ts

import { TelegramSender } from "./telegram-sender";
import { ReceivedMessage } from "./telegram-receiver";
import { Database } from "../../database/db";

interface AgentStatus {
  agentId: string;
  status: "working" | "idle" | "blocked" | "error";
  currentTask?: string;
  lastActivity: Date;
}

interface Summary {
  generatedAt: Date;
  timeWindow: string;
  agents: AgentStatus[];
  recentActivityCount: number;
  recentActivityHighlights: string[];
  pendingQuestions: number;
  oldestQuestion?: { id: string; age: string; content: string };
  issuesDetected: number;
  issueHighlights: string[];
}

export class SummaryHandler {
  private db: Database;
  private sender: TelegramSender;

  constructor(db: Database, sender: TelegramSender) {
    this.db = db;
    this.sender = sender;
  }

  async handleSummaryCommand(message: ReceivedMessage): Promise<void> {
    const { botType, text } = message;

    // Parse time window from command
    const timeWindow = this.parseTimeWindow(text);

    // Build summary
    const summary = await this.buildSummary(timeWindow);

    // Format message
    const formattedMessage = this.formatSummary(summary);

    // Send via same bot
    await this.sender.sendMessage({
      agentType: botType,
      text: formattedMessage,
      parseMode: "Markdown",
    });
  }

  private parseTimeWindow(text: string): { hours: number; label: string } {
    // Parse formats: /summary, /summary 2h, /summary 30m
    const match = text.match(/\/summary\s+(\d+)(h|m)?/i);

    if (!match) {
      return { hours: 1, label: "last hour" };
    }

    const value = parseInt(match[1]);
    const unit = match[2]?.toLowerCase() || "h";

    if (unit === "m") {
      return { hours: value / 60, label: `last ${value} minutes` };
    }

    return { hours: value, label: `last ${value} hour${value > 1 ? "s" : ""}` };
  }

  private async buildSummary(timeWindow: {
    hours: number;
    label: string;
  }): Promise<Summary> {
    const windowStart = new Date(
      Date.now() - timeWindow.hours * 60 * 60 * 1000,
    );

    // Get agent statuses
    const agents = await this.getAgentStatuses();

    // Get recent activity
    const activity = await this.getRecentActivity(windowStart);

    // Get pending questions
    const questions = await this.getPendingQuestions();

    // Get issues
    const issues = await this.getRecentIssues(windowStart);

    return {
      generatedAt: new Date(),
      timeWindow: timeWindow.label,
      agents,
      recentActivityCount: activity.count,
      recentActivityHighlights: activity.highlights,
      pendingQuestions: questions.count,
      oldestQuestion: questions.oldest,
      issuesDetected: issues.count,
      issueHighlights: issues.highlights,
    };
  }

  private formatSummary(summary: Summary): string {
    let msg = `üìä *Vibe Platform Summary*\n`;
    msg += `_${summary.timeWindow}_\n\n`;

    // Agent statuses
    msg += `*Agents:*\n`;
    for (const agent of summary.agents) {
      const emoji = this.getStatusEmoji(agent.status);
      msg += `${emoji} \`${agent.agentId}\`: ${agent.status}`;
      if (agent.currentTask) {
        msg += ` - ${agent.currentTask.substring(0, 30)}...`;
      }
      msg += "\n";
    }

    // Activity
    msg += `\n*Activity:* ${summary.recentActivityCount} events\n`;
    if (summary.recentActivityHighlights.length > 0) {
      for (const highlight of summary.recentActivityHighlights.slice(0, 3)) {
        msg += `‚Ä¢ ${highlight}\n`;
      }
    }

    // Questions
    msg += `\n*Pending Questions:* ${summary.pendingQuestions}\n`;
    if (summary.oldestQuestion) {
      msg += `_Oldest:_ ${summary.oldestQuestion.age} ago\n`;
      msg += `"${summary.oldestQuestion.content.substring(0, 50)}..."\n`;
    }

    // Issues
    if (summary.issuesDetected > 0) {
      msg += `\n‚ö†Ô∏è *Issues Detected:* ${summary.issuesDetected}\n`;
      for (const issue of summary.issueHighlights.slice(0, 3)) {
        msg += `‚Ä¢ ${issue}\n`;
      }
    }

    msg += `\n_Generated: ${summary.generatedAt.toLocaleTimeString()}_`;

    return msg;
  }

  private getStatusEmoji(status: string): string {
    const emojis: Record<string, string> = {
      working: "üîµ",
      idle: "‚ö™",
      blocked: "üü°",
      error: "üî¥",
    };
    return emojis[status] || "‚ö´";
  }

  private async getAgentStatuses(): Promise<AgentStatus[]> {
    // Query from event bus state or database
    // This would integrate with MON-002 (Event Bus Listener)
    const results = await this.db.query(`
      SELECT DISTINCT agent_id, status, current_task, last_activity
      FROM agent_states
      ORDER BY last_activity DESC
    `);

    return results.map((r: any) => ({
      agentId: r.agent_id,
      status: r.status,
      currentTask: r.current_task,
      lastActivity: new Date(r.last_activity),
    }));
  }

  private async getRecentActivity(since: Date): Promise<{
    count: number;
    highlights: string[];
  }> {
    const results = await this.db.query(
      `
      SELECT type, description, created_at
      FROM activity_log
      WHERE created_at > ?
      ORDER BY created_at DESC
      LIMIT 10
    `,
      [since.toISOString()],
    );

    return {
      count: results.length,
      highlights: results.slice(0, 5).map((r: any) => r.description),
    };
  }

  private async getPendingQuestions(): Promise<{
    count: number;
    oldest?: { id: string; age: string; content: string };
  }> {
    const results = await this.db.query(`
      SELECT id, content, created_at
      FROM questions
      WHERE status = 'pending'
      ORDER BY created_at ASC
    `);

    if (results.length === 0) {
      return { count: 0 };
    }

    const oldest = results[0];
    const ageMs = Date.now() - new Date(oldest.created_at).getTime();
    const ageMinutes = Math.floor(ageMs / 60000);

    return {
      count: results.length,
      oldest: {
        id: oldest.id,
        age:
          ageMinutes > 60
            ? `${Math.floor(ageMinutes / 60)}h`
            : `${ageMinutes}m`,
        content: oldest.content,
      },
    };
  }

  private async getRecentIssues(since: Date): Promise<{
    count: number;
    highlights: string[];
  }> {
    // Would integrate with MON-005 (Detection Engine)
    const results = await this.db.query(
      `
      SELECT type, description, detected_at
      FROM detected_issues
      WHERE detected_at > ?
      ORDER BY detected_at DESC
    `,
      [since.toISOString()],
    );

    return {
      count: results.length,
      highlights: results
        .slice(0, 5)
        .map((r: any) => `${r.type}: ${r.description.substring(0, 50)}`),
    };
  }
}
```

---

## Example Output

```
üìä *Vibe Platform Summary*
_last hour_

*Agents:*
üîµ `spec-agent-123`: working - Generating auth spec...
‚ö™ `build-agent-456`: idle
üü° `validation-agent-789`: blocked
üî¥ `sia-agent-012`: error

*Activity:* 24 events
‚Ä¢ Spec agent started auth specification
‚Ä¢ Build agent completed 3 tasks
‚Ä¢ Validation agent blocked on coverage question

*Pending Questions:* 2
_Oldest:_ 15m ago
"What minimum coverage threshold should I use..."

‚ö†Ô∏è *Issues Detected:* 1
‚Ä¢ repeated_error: Same TypeError 3 times

_Generated: 2:45:32 PM_
```

---

## Validation

```bash
npx tsc --noEmit server/communication/summary-handler.ts
npm test -- --grep "summary-handler"
```
