# TAK-044: Task Decomposer Service

---

## Metadata

| Field | Value |
|-------|-------|
| **Phase** | Additional Capabilities |
| **Depends On** | TAK-016 |
| **Blocks** | None |
| **Priority** | P3 |
| **Owner** | Build Agent |

---

## Summary

Implement a TaskDecomposer service that detects oversized tasks and suggests breakdowns into smaller, manageable subtasks while maintaining parent-child relationships.

---

## Requirements

1. **Oversize Detection**:
   - Detect tasks that are too large based on description length
   - Identify multiple distinct deliverables in single task
   - Flag tasks with unrealistic effort estimates

2. **Subtask Generation**:
   - Break down large tasks into logical subtasks
   - Suggest meaningful titles and descriptions
   - Maintain coherent scope boundaries

3. **Relationship Management**:
   - Create parent-child task relationships
   - Set appropriate dependencies between subtasks
   - Track combined progress

4. **Effort Estimation**:
   - Estimate individual subtask effort
   - Ensure subtask efforts sum reasonably
   - Apply historical calibration

---

## Pass Criteria

**PASS** when ALL of the following are true:

| # | Criterion | How to Verify |
|---|-----------|---------------|
| 1 | File exists | `test -f server/services/task-agent/task-decomposer.ts` returns 0 |
| 2 | Has decompose method | `grep -q "decompose\|Decompose" server/services/task-agent/task-decomposer.ts` returns 0 |
| 3 | Has subtask creation | `grep -q "subtask\|Subtask" server/services/task-agent/task-decomposer.ts` returns 0 |
| 4 | Compiles | `npx tsc --noEmit server/services/task-agent/task-decomposer.ts` passes |

**FAIL** if any criterion is not met.

---

## Output Files

```
server/services/task-agent/
└── task-decomposer.ts
```

---

## Code Template

```typescript
// Task Decomposer Service
// Breaks large tasks into manageable subtasks

import { db } from '../../database';
import type { Task } from '../../../types/task-agent';

interface DecompositionSuggestion {
  parentTaskId: string;
  shouldDecompose: boolean;
  reasons: string[];
  suggestedSubtasks: SubtaskSuggestion[];
  combinedEffort: number;
}

interface SubtaskSuggestion {
  title: string;
  description: string;
  category: string;
  estimatedEffort: number;  // minutes
  order: number;
  dependsOnIndex?: number;  // Index of subtask this depends on
}

export class TaskDecomposer {
  private maxDescriptionLength = 1000;
  private maxAcceptanceCriteria = 8;
  private maxEffortMinutes = 480;  // 8 hours

  async analyzeTask(taskId: string): Promise<DecompositionSuggestion> {
    const task = db.prepare('SELECT * FROM tasks WHERE id = ?').get(taskId) as Task;

    if (!task) {
      throw new Error(`Task ${taskId} not found`);
    }

    const reasons: string[] = [];
    let shouldDecompose = false;

    // Check description length
    if (task.description.length > this.maxDescriptionLength) {
      reasons.push(`Description is ${task.description.length} chars (max: ${this.maxDescriptionLength})`);
      shouldDecompose = true;
    }

    // Check acceptance criteria count
    const criteriaCount = task.acceptanceCriteria?.length || 0;
    if (criteriaCount > this.maxAcceptanceCriteria) {
      reasons.push(`Has ${criteriaCount} acceptance criteria (max: ${this.maxAcceptanceCriteria})`);
      shouldDecompose = true;
    }

    // Check for multiple deliverables in description
    const deliverableMarkers = this.countDeliverables(task.description);
    if (deliverableMarkers > 3) {
      reasons.push(`Contains ${deliverableMarkers} distinct deliverables`);
      shouldDecompose = true;
    }

    // Check effort estimate
    if (task.estimatedEffort) {
      const effortMinutes = this.parseEffortToMinutes(task.estimatedEffort);
      if (effortMinutes > this.maxEffortMinutes) {
        reasons.push(`Estimated effort ${task.estimatedEffort} exceeds ${this.maxEffortMinutes / 60} hours`);
        shouldDecompose = true;
      }
    }

    // Generate subtask suggestions if decomposition needed
    const suggestedSubtasks = shouldDecompose
      ? await this.generateSubtasks(task)
      : [];

    const combinedEffort = suggestedSubtasks.reduce(
      (sum, st) => sum + st.estimatedEffort,
      0
    );

    return {
      parentTaskId: taskId,
      shouldDecompose,
      reasons,
      suggestedSubtasks,
      combinedEffort
    };
  }

  private countDeliverables(description: string): number {
    // Count indicators of separate deliverables
    const patterns = [
      /\band\b/gi,
      /\b(also|additionally|furthermore)\b/gi,
      /\d+\.\s+/g,  // Numbered lists
      /[-*]\s+/g,   // Bullet points
      /\b(then|after that|next)\b/gi,
    ];

    let count = 1;  // Start with 1 for the base task
    for (const pattern of patterns) {
      const matches = description.match(pattern);
      if (matches) {
        count += Math.min(matches.length, 3);  // Cap each pattern's contribution
      }
    }

    return Math.min(count, 10);  // Cap total
  }

  private parseEffortToMinutes(effort: string): number {
    const hourMatch = effort.match(/(\d+)\s*h/i);
    const dayMatch = effort.match(/(\d+)\s*d/i);
    const minMatch = effort.match(/(\d+)\s*m/i);

    let minutes = 0;
    if (hourMatch) minutes += parseInt(hourMatch[1]) * 60;
    if (dayMatch) minutes += parseInt(dayMatch[1]) * 480;  // 8-hour days
    if (minMatch) minutes += parseInt(minMatch[1]);

    return minutes || 60;  // Default 1 hour if unparseable
  }

  private async generateSubtasks(task: Task): Promise<SubtaskSuggestion[]> {
    const subtasks: SubtaskSuggestion[] = [];

    // Strategy 1: Break by acceptance criteria
    if (task.acceptanceCriteria?.length > 3) {
      const groups = this.groupCriteria(task.acceptanceCriteria);
      for (let i = 0; i < groups.length; i++) {
        subtasks.push({
          title: `${task.title} - Part ${i + 1}`,
          description: `Implement: ${groups[i].join(', ')}`,
          category: task.category,
          estimatedEffort: Math.ceil(60 * groups[i].length / 2),  // 30 min per criterion
          order: i + 1,
          dependsOnIndex: i > 0 ? i - 1 : undefined
        });
      }
      return subtasks;
    }

    // Strategy 2: Break by phase (design, implement, test)
    subtasks.push({
      title: `${task.title} - Design`,
      description: `Design and plan implementation for: ${task.description.slice(0, 200)}`,
      category: 'investigation',
      estimatedEffort: 60,
      order: 1
    });

    subtasks.push({
      title: `${task.title} - Implement`,
      description: `Implement the core functionality: ${task.description.slice(0, 200)}`,
      category: task.category,
      estimatedEffort: 180,
      order: 2,
      dependsOnIndex: 0
    });

    subtasks.push({
      title: `${task.title} - Test & Document`,
      description: `Write tests and documentation for: ${task.title}`,
      category: 'testing',
      estimatedEffort: 60,
      order: 3,
      dependsOnIndex: 1
    });

    return subtasks;
  }

  private groupCriteria(criteria: string[]): string[][] {
    const groupSize = 3;
    const groups: string[][] = [];

    for (let i = 0; i < criteria.length; i += groupSize) {
      groups.push(criteria.slice(i, i + groupSize));
    }

    return groups;
  }

  async createSubtasks(
    parentTaskId: string,
    subtasks: SubtaskSuggestion[]
  ): Promise<string[]> {
    const createdIds: string[] = [];

    for (const subtask of subtasks) {
      const id = `task-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;

      db.prepare(`
        INSERT INTO tasks (id, title, description, category, status, parent_id, priority, created_by, created_at, updated_at)
        VALUES (?, ?, ?, ?, 'draft', ?, ?, 'task-decomposer', datetime('now'), datetime('now'))
      `).run(
        id,
        subtask.title,
        subtask.description,
        subtask.category,
        parentTaskId,
        subtask.order * 10
      );

      createdIds.push(id);

      // Create dependency if specified
      if (subtask.dependsOnIndex !== undefined && subtask.dependsOnIndex < createdIds.length) {
        const dependsOnId = createdIds[subtask.dependsOnIndex];
        db.prepare(`
          INSERT INTO task_relationships (id, source_task_id, target_task_id, relationship_type, created_at)
          VALUES (?, ?, ?, 'depends_on', datetime('now'))
        `).run(
          `rel-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
          id,
          dependsOnId
        );
      }
    }

    return createdIds;
  }
}

export default TaskDecomposer;
```

---

## Gotchas

- Preserve the original task as parent for tracking
- Subtask dependencies should be acyclic
- AI-generated breakdowns need human review

---

## Validation

```bash
# Type check
npx tsc --noEmit server/services/task-agent/task-decomposer.ts

# Run unit tests
npm test -- --grep "task-decomposer"
```

---

## Next Steps

After completing this task:
1. Integrate with ValidationGate to flag oversized tasks
2. Add UI for reviewing decomposition suggestions
3. Create Telegram command for decomposition
