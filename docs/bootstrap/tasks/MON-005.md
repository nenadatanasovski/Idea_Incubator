# MON-005: Detection Engine

---

## Metadata

| Field | Value |
|-------|-------|
| **Phase** | 2 - Monitoring Agent |
| **Depends On** | MON-004 |
| **Blocks** | MON-006 |
| **Priority** | P1 |
| **Owner** | Human (then Build Agent) |

---

## Summary

Implement the Detection Engine that applies rules, thresholds, and pattern matching to identify issues like repeated errors, progress stagnation, and infinite loops.

---

## Requirements

1. **Detection Rules**:
   - Repeated same error (3+ in 1 minute)
   - Progress stagnation (no change in 3x expected duration)
   - Infinite loop pattern (repeating task sequences)
   - Resource exhaustion (memory > 90%, tokens > 95%)
   - UI/Event Bus divergence

2. **Task-Type Awareness**:
   - Expected duration by task type
   - Acceptable variation ranges
   - Known slow tasks exempted

3. **Confidence Scores**:
   - Each detection has confidence 0-1
   - Low confidence → log/alert only
   - High confidence → action possible

---

## Pass Criteria

**PASS** when ALL of the following are true:

| # | Criterion | How to Verify |
|---|-----------|---------------|
| 1 | File exists | `test -f agents/monitoring/detection-engine.ts` returns 0 |
| 2 | Exports DetectionEngine | `grep -q "export class DetectionEngine" agents/monitoring/detection-engine.ts` returns 0 |
| 3 | Has detect method | `grep -q "detect(" agents/monitoring/detection-engine.ts` returns 0 |
| 4 | Has 5+ detection rules | `grep -c "DetectionRule\|rule:" agents/monitoring/detection-engine.ts` >= 5 |
| 5 | Has task duration estimates | `grep -q "TASK_DURATION\|expectedDuration" agents/monitoring/detection-engine.ts` returns 0 |
| 6 | Returns confidence | `grep -q "confidence" agents/monitoring/detection-engine.ts` returns 0 |
| 7 | TypeScript compiles | `npx tsc --noEmit agents/monitoring/detection-engine.ts` returns 0 |
| 8 | Unit tests pass | `npm test -- --grep "detection-engine"` passes |

**FAIL** if any criterion is not met.

---

## Output Files

```
agents/monitoring/
└── detection-engine.ts
```

---

## Code Template

```typescript
// agents/monitoring/detection-engine.ts

import { ReconciledState, ReconciledAgent } from './state-reconciler';

export interface DetectedIssue {
  id: string;
  type: IssueType;
  agentId: string;
  description: string;
  confidence: number;
  evidence: any;
  detectedAt: Date;
}

export type IssueType =
  | 'repeated_error'
  | 'progress_stagnation'
  | 'infinite_loop'
  | 'resource_exhaustion'
  | 'ui_divergence'
  | 'agent_unresponsive';

interface DetectionRule {
  name: string;
  type: IssueType;
  check: (state: ReconciledState, history: AgentHistory) => DetectedIssue | null;
}

interface AgentHistory {
  errors: { message: string; timestamp: Date }[];
  taskTransitions: { taskId: string; timestamp: Date }[];
  progressUpdates: { progress: number; timestamp: Date }[];
}

const TASK_DURATION_ESTIMATES: Record<string, number> = {
  migration: 5_000,
  query: 2_000,
  read_file: 1_000,
  write_file: 2_000,
  claude_call: 30_000,
  spec_generation: 120_000,
  code_generation: 90_000,
  test_run: 60_000,
};

export class DetectionEngine {
  private rules: DetectionRule[];
  private agentHistories: Map<string, AgentHistory> = new Map();

  constructor(config?: DetectionConfig) {
    this.rules = this.initializeRules();
  }

  detect(state: ReconciledState): DetectedIssue[] {
    const issues: DetectedIssue[] = [];

    for (const agent of state.agents) {
      const history = this.getHistory(agent.agentId);

      for (const rule of this.rules) {
        const issue = rule.check(state, history);
        if (issue) {
          issues.push(issue);
        }
      }

      this.updateHistory(agent);
    }

    return issues;
  }

  private initializeRules(): DetectionRule[] {
    return [
      {
        name: 'repeated_same_error',
        type: 'repeated_error',
        check: (state, history) => {
          const recentErrors = history.errors.filter(e =>
            Date.now() - e.timestamp.getTime() < 60_000
          );
          if (recentErrors.length < 3) return null;

          // Check for same error message
          const errorCounts = new Map<string, number>();
          for (const e of recentErrors) {
            errorCounts.set(e.message, (errorCounts.get(e.message) || 0) + 1);
          }

          for (const [message, count] of errorCounts) {
            if (count >= 3) {
              return {
                id: `err-${Date.now()}`,
                type: 'repeated_error',
                agentId: state.agents[0]?.agentId || 'unknown',
                description: `Same error repeated ${count} times in 1 minute`,
                confidence: 0.9,
                evidence: { message, count, recentErrors },
                detectedAt: new Date(),
              };
            }
          }
          return null;
        },
      },

      {
        name: 'progress_stagnation',
        type: 'progress_stagnation',
        check: (state, history) => {
          // Check for no progress updates in 3x expected duration
          const recentProgress = history.progressUpdates.filter(p =>
            Date.now() - p.timestamp.getTime() < 30_000
          );

          if (recentProgress.length === 0) {
            const agent = state.agents[0];
            if (agent?.eventBusState?.currentTask) {
              const taskType = this.inferTaskType(agent.eventBusState.currentTask);
              const expected = TASK_DURATION_ESTIMATES[taskType] || 60_000;
              const elapsed = Date.now() - (agent.eventBusState.lastActivity?.getTime() || 0);

              if (elapsed > expected * 3) {
                return {
                  id: `stag-${Date.now()}`,
                  type: 'progress_stagnation',
                  agentId: agent.agentId,
                  description: `No progress for ${Math.round(elapsed / 1000)}s (expected ${Math.round(expected / 1000)}s)`,
                  confidence: 0.7,
                  evidence: { elapsed, expected, taskType },
                  detectedAt: new Date(),
                };
              }
            }
          }
          return null;
        },
      },

      {
        name: 'infinite_loop_pattern',
        type: 'infinite_loop',
        check: (state, history) => {
          const recentTasks = history.taskTransitions.slice(-10);
          if (recentTasks.length < 6) return null;

          const taskSequence = recentTasks.map(t => t.taskId).join(',');
          const hasLoop = /(.+,.+)\1{2,}/.test(taskSequence);

          if (hasLoop) {
            return {
              id: `loop-${Date.now()}`,
              type: 'infinite_loop',
              agentId: state.agents[0]?.agentId || 'unknown',
              description: 'Repeating task sequence detected',
              confidence: 0.95,
              evidence: { taskSequence, recentTasks },
              detectedAt: new Date(),
            };
          }
          return null;
        },
      },

      // Additional rules...
    ];
  }

  private inferTaskType(taskDescription: string): string {
    if (taskDescription.includes('migration')) return 'migration';
    if (taskDescription.includes('query')) return 'query';
    if (taskDescription.includes('claude') || taskDescription.includes('generate')) return 'claude_call';
    return 'unknown';
  }

  private getHistory(agentId: string): AgentHistory {
    return this.agentHistories.get(agentId) || {
      errors: [],
      taskTransitions: [],
      progressUpdates: [],
    };
  }

  private updateHistory(agent: ReconciledAgent): void {
    // Update history with latest state
  }
}
```

---

## Validation

```bash
npx tsc --noEmit agents/monitoring/detection-engine.ts
npm test -- --grep "detection-engine"
```
