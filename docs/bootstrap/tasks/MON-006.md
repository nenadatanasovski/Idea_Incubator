# MON-006: Response Escalator

---

## Metadata

| Field          | Value                    |
| -------------- | ------------------------ |
| **Phase**      | 2 - Monitoring Agent     |
| **Depends On** | MON-005                  |
| **Blocks**     | MON-007                  |
| **Priority**   | P1                       |
| **Owner**      | Human (then Build Agent) |

---

## Summary

Implement the Response Escalator that maps detected issues to appropriate response levels, with automatic escalation for recurring or unresolved issues.

---

## Requirements

1. **Response Levels** (7 levels):
   - OBSERVE (0): Just log
   - LOG (1): Structured log for analysis
   - ALERT (2): Non-blocking dashboard notification
   - WARN (3): Attention-getting notification + question queue
   - PAUSE (4): Stop agent from new work
   - RESTART (5): Kill and restart agent
   - KILL (6): Kill without restart, require human
   - EMERGENCY (7): Halt entire session

2. **Escalation Logic**:
   - Confidence to level mapping
   - Recurring issue escalation
   - Previous response ineffective → escalate

3. **Human Approval**:
   - KILL and EMERGENCY always require human approval
   - Submitted via question queue (APPROVAL type)

---

## Pass Criteria

**PASS** when ALL of the following are true:

| #   | Criterion                 | How to Verify                                                                                                       |
| --- | ------------------------- | ------------------------------------------------------------------------------------------------------------------- |
| 1   | File exists               | `test -f agents/monitoring/response-escalator.ts` returns 0                                                         |
| 2   | Exports ResponseEscalator | `grep -q "export class ResponseEscalator" agents/monitoring/response-escalator.ts` returns 0                        |
| 3   | Has 7 response levels     | `grep -c "OBSERVE\|LOG\|ALERT\|WARN\|PAUSE\|RESTART\|KILL\|EMERGENCY" agents/monitoring/response-escalator.ts` >= 7 |
| 4   | Has getResponse method    | `grep -q "getResponse(" agents/monitoring/response-escalator.ts` returns 0                                          |
| 5   | Tracks issue history      | `grep -q "issueHistory" agents/monitoring/response-escalator.ts` returns 0                                          |
| 6   | Requires human approval   | `grep -q "humanApproval\|requiresApproval" agents/monitoring/response-escalator.ts` returns 0                       |
| 7   | TypeScript compiles       | `npx tsc --noEmit agents/monitoring/response-escalator.ts` returns 0                                                |
| 8   | Unit tests pass           | `npm test -- --grep "response-escalator"` passes                                                                    |

**FAIL** if any criterion is not met.

---

## Output Files

```
agents/monitoring/
└── response-escalator.ts
```

---

## Code Template

```typescript
// agents/monitoring/response-escalator.ts

import { DetectedIssue } from "./detection-engine";

export enum ResponseLevel {
  OBSERVE = 0,
  LOG = 1,
  ALERT = 2,
  WARN = 3,
  PAUSE = 4,
  RESTART = 5,
  KILL = 6,
  EMERGENCY = 7,
}

export interface ResponseAction {
  level: ResponseLevel;
  requiresConfirmation: boolean;
  reversible: boolean;
  humanApprovalRequired: boolean;
  cooldown: number; // ms before escalating
}

export interface ResponseDecision {
  level: ResponseLevel;
  action: ResponseAction;
  issue: DetectedIssue;
  rationale: string;
  escalatedFrom?: ResponseLevel;
}

interface IssueRecord {
  issue: DetectedIssue;
  responseLevel: ResponseLevel;
  timestamp: Date;
  resolved: boolean;
}

const RESPONSE_ACTIONS: Record<ResponseLevel, ResponseAction> = {
  [ResponseLevel.OBSERVE]: {
    level: ResponseLevel.OBSERVE,
    requiresConfirmation: false,
    reversible: true,
    humanApprovalRequired: false,
    cooldown: 0,
  },
  [ResponseLevel.LOG]: {
    level: ResponseLevel.LOG,
    requiresConfirmation: false,
    reversible: true,
    humanApprovalRequired: false,
    cooldown: 0,
  },
  [ResponseLevel.ALERT]: {
    level: ResponseLevel.ALERT,
    requiresConfirmation: false,
    reversible: true,
    humanApprovalRequired: false,
    cooldown: 10_000,
  },
  [ResponseLevel.WARN]: {
    level: ResponseLevel.WARN,
    requiresConfirmation: true,
    reversible: true,
    humanApprovalRequired: false,
    cooldown: 30_000,
  },
  [ResponseLevel.PAUSE]: {
    level: ResponseLevel.PAUSE,
    requiresConfirmation: true,
    reversible: true,
    humanApprovalRequired: false,
    cooldown: 60_000,
  },
  [ResponseLevel.RESTART]: {
    level: ResponseLevel.RESTART,
    requiresConfirmation: true,
    reversible: false,
    humanApprovalRequired: false,
    cooldown: 120_000,
  },
  [ResponseLevel.KILL]: {
    level: ResponseLevel.KILL,
    requiresConfirmation: true,
    reversible: false,
    humanApprovalRequired: true, // ALWAYS requires human
    cooldown: 300_000,
  },
  [ResponseLevel.EMERGENCY]: {
    level: ResponseLevel.EMERGENCY,
    requiresConfirmation: true,
    reversible: false,
    humanApprovalRequired: true, // ALWAYS requires human
    cooldown: 600_000,
  },
};

export class ResponseEscalator {
  private issueHistory: Map<string, IssueRecord[]> = new Map();

  getResponse(issue: DetectedIssue): ResponseDecision {
    const agentHistory = this.getAgentHistory(issue.agentId);
    const sameTypeIssues = agentHistory.filter(
      (r) => r.issue.type === issue.type,
    );

    // Base level from confidence
    let level = this.confidenceToLevel(issue.confidence);
    let escalatedFrom: ResponseLevel | undefined;

    // Escalate if issue is recurring
    if (sameTypeIssues.length >= 3) {
      escalatedFrom = level;
      level = Math.min(level + 1, ResponseLevel.RESTART);
    }
    if (sameTypeIssues.length >= 5) {
      escalatedFrom = level;
      level = Math.min(level + 1, ResponseLevel.KILL);
    }

    // Escalate if previous response didn't work
    const lastResponse = sameTypeIssues.at(-1);
    if (
      lastResponse &&
      !lastResponse.resolved &&
      lastResponse.responseLevel >= level
    ) {
      escalatedFrom = level;
      level = Math.min(lastResponse.responseLevel + 1, ResponseLevel.EMERGENCY);
    }

    const action = RESPONSE_ACTIONS[level];
    const rationale = this.buildRationale(
      issue,
      level,
      escalatedFrom,
      sameTypeIssues.length,
    );

    // Record this response
    this.recordResponse(issue, level);

    return {
      level,
      action,
      issue,
      rationale,
      escalatedFrom,
    };
  }

  markResolved(issueId: string): void {
    for (const records of this.issueHistory.values()) {
      const record = records.find((r) => r.issue.id === issueId);
      if (record) {
        record.resolved = true;
      }
    }
  }

  private confidenceToLevel(confidence: number): ResponseLevel {
    if (confidence < 0.5) return ResponseLevel.LOG;
    if (confidence < 0.7) return ResponseLevel.ALERT;
    if (confidence < 0.85) return ResponseLevel.WARN;
    if (confidence < 0.95) return ResponseLevel.PAUSE;
    return ResponseLevel.RESTART;
  }

  private getAgentHistory(agentId: string): IssueRecord[] {
    return this.issueHistory.get(agentId) || [];
  }

  private recordResponse(issue: DetectedIssue, level: ResponseLevel): void {
    const history = this.issueHistory.get(issue.agentId) || [];
    history.push({
      issue,
      responseLevel: level,
      timestamp: new Date(),
      resolved: false,
    });
    this.issueHistory.set(issue.agentId, history);
  }

  private buildRationale(
    issue: DetectedIssue,
    level: ResponseLevel,
    escalatedFrom: ResponseLevel | undefined,
    occurrenceCount: number,
  ): string {
    let rationale = `Issue type: ${issue.type}, confidence: ${issue.confidence.toFixed(2)}`;

    if (escalatedFrom !== undefined) {
      rationale += `. Escalated from ${ResponseLevel[escalatedFrom]} due to`;
      if (occurrenceCount >= 3) {
        rationale += ` recurring issue (${occurrenceCount} times)`;
      } else {
        rationale += ` previous response ineffective`;
      }
    }

    return rationale;
  }
}
```

---

## Validation

```bash
npx tsc --noEmit agents/monitoring/response-escalator.ts
npm test -- --grep "response-escalator"
```
