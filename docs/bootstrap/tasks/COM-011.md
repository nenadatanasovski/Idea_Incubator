# COM-011: Question-Gated Execution (Halt Mechanism)

---

## Metadata

| Field | Value |
|-------|-------|
| **Phase** | 0 - Communication Core |
| **Depends On** | COM-010, QUE-001 |
| **Blocks** | MON-007 |
| **Priority** | P1 |
| **Owner** | Build Agent |

---

## Summary

Implement the question-gated execution system that halts agent work when blocking questions exist, and resumes when answers are received.

---

## Context

### The Halting Requirement

> "Its key that the monitoring agent has the capability to halt certain sessions and tasks until an answer is given."

This is a safety mechanism. Before any agent does work, it checks:
1. Do I have blocking questions pending?
2. Is my session halted by a HARD_HALT question?

If yes to either, the agent waits.

### Scope of Halting

| Question Type | Halts Agent | Halts Session | Halts All |
|---------------|-------------|---------------|-----------|
| BLOCKING | Yes | No | No |
| APPROVAL | Yes | Yes | No |
| EMERGENCY | Yes | Yes | Yes |
| ESCALATION | Yes | No | No |
| Others | No | No | No |

---

## Requirements

1. **Pre-Work Check**:
   - `canProceed(agentId)` → boolean
   - Checks question queue for blocking questions
   - Checks for session-level halts
   - Checks for system-wide halts

2. **Wait Mechanism**:
   - `waitForClearance(agentId)` → Promise
   - Polls for answer or timeout
   - Returns when cleared to proceed
   - Throws if timeout with no default

3. **Halt Management**:
   - Track halted sessions
   - Track halted agents
   - Track system-wide halt status

4. **Resume Notification**:
   - Emit event when agent cleared
   - Include answer in payload
   - Log all halt/resume events

---

## Pass Criteria

**PASS** when ALL of the following are true:

| # | Criterion | How to Verify |
|---|-----------|---------------|
| 1 | File exists | `test -f server/communication/execution-gate.ts` returns 0 |
| 2 | Exports ExecutionGate | `grep -q "export class ExecutionGate" server/communication/execution-gate.ts` returns 0 |
| 3 | Has canProceed method | `grep -q "canProceed(" server/communication/execution-gate.ts` returns 0 |
| 4 | Has waitForClearance method | `grep -q "waitForClearance\|waitFor" server/communication/execution-gate.ts` returns 0 |
| 5 | Has halt tracking | `grep -q "haltedAgents\|haltedSessions" server/communication/execution-gate.ts` returns 0 |
| 6 | TypeScript compiles | `npx tsc --noEmit server/communication/execution-gate.ts` returns 0 |
| 7 | Unit tests pass | `npm test -- --grep "execution-gate"` passes |

**FAIL** if any criterion is not met.

---

## Output Files

```
server/communication/
└── execution-gate.ts
```

---

## Code Template

```typescript
// server/communication/execution-gate.ts

import { EventEmitter } from 'events';
import { Database } from '../../database/db';

type QuestionType =
  | 'BLOCKING' | 'CLARIFYING' | 'CONFIRMING' | 'PREFERENCE'
  | 'ALERT' | 'ESCALATION' | 'APPROVAL' | 'DECISION';

interface BlockingQuestion {
  id: string;
  agentId: string;
  sessionId?: string;
  type: QuestionType;
  haltsSession: boolean;
  haltsAll: boolean;
}

interface ClearanceResult {
  cleared: boolean;
  reason: 'answered' | 'timeout' | 'cancelled';
  answer?: any;
}

export class ExecutionGate extends EventEmitter {
  private db: Database;
  private haltedAgents: Set<string> = new Set();
  private haltedSessions: Set<string> = new Set();
  private systemHalted: boolean = false;
  private waitingAgents: Map<string, { resolve: (result: ClearanceResult) => void }> = new Map();

  constructor(db: Database) {
    super();
    this.db = db;
  }

  async canProceed(agentId: string, sessionId?: string): Promise<boolean> {
    // Check system-wide halt
    if (this.systemHalted) {
      return false;
    }

    // Check session halt
    if (sessionId && this.haltedSessions.has(sessionId)) {
      return false;
    }

    // Check agent halt
    if (this.haltedAgents.has(agentId)) {
      return false;
    }

    // Check for blocking questions in queue
    const blockingQuestions = await this.getBlockingQuestions(agentId, sessionId);
    return blockingQuestions.length === 0;
  }

  async waitForClearance(
    agentId: string,
    sessionId?: string,
    timeoutMs?: number
  ): Promise<ClearanceResult> {
    // First check if already clear
    if (await this.canProceed(agentId, sessionId)) {
      return { cleared: true, reason: 'answered' };
    }

    // Create promise that resolves when cleared
    return new Promise((resolve, reject) => {
      const waiter = { resolve };
      this.waitingAgents.set(agentId, waiter);

      // Set up timeout if specified
      if (timeoutMs) {
        setTimeout(() => {
          if (this.waitingAgents.has(agentId)) {
            this.waitingAgents.delete(agentId);
            resolve({ cleared: false, reason: 'timeout' });
          }
        }, timeoutMs);
      }

      // Poll for clearance
      const pollInterval = setInterval(async () => {
        if (!this.waitingAgents.has(agentId)) {
          clearInterval(pollInterval);
          return;
        }

        if (await this.canProceed(agentId, sessionId)) {
          clearInterval(pollInterval);
          this.waitingAgents.delete(agentId);
          resolve({ cleared: true, reason: 'answered' });
        }
      }, 1000); // Check every second
    });
  }

  haltAgent(agentId: string, questionId: string): void {
    this.haltedAgents.add(agentId);
    console.log(`Agent ${agentId} halted by question ${questionId}`);
    this.emit('agent:halted', { agentId, questionId });
  }

  haltSession(sessionId: string, questionId: string): void {
    this.haltedSessions.add(sessionId);
    console.log(`Session ${sessionId} halted by question ${questionId}`);
    this.emit('session:halted', { sessionId, questionId });
  }

  haltAll(questionId: string): void {
    this.systemHalted = true;
    console.log(`SYSTEM HALTED by question ${questionId}`);
    this.emit('system:halted', { questionId });
  }

  resumeAgent(agentId: string, answer?: any): void {
    this.haltedAgents.delete(agentId);
    console.log(`Agent ${agentId} resumed`);

    // Notify waiting agent
    const waiter = this.waitingAgents.get(agentId);
    if (waiter) {
      waiter.resolve({ cleared: true, reason: 'answered', answer });
      this.waitingAgents.delete(agentId);
    }

    this.emit('agent:resumed', { agentId, answer });
  }

  resumeSession(sessionId: string, answer?: any): void {
    this.haltedSessions.delete(sessionId);
    console.log(`Session ${sessionId} resumed`);
    this.emit('session:resumed', { sessionId, answer });
  }

  resumeAll(answer?: any): void {
    this.systemHalted = false;
    console.log('SYSTEM RESUMED');
    this.emit('system:resumed', { answer });
  }

  getHaltStatus(): {
    systemHalted: boolean;
    haltedSessions: string[];
    haltedAgents: string[];
  } {
    return {
      systemHalted: this.systemHalted,
      haltedSessions: Array.from(this.haltedSessions),
      haltedAgents: Array.from(this.haltedAgents),
    };
  }

  async onQuestionCreated(question: BlockingQuestion): Promise<void> {
    if (!this.isHaltingQuestion(question.type)) {
      return;
    }

    // Determine halt scope
    if (question.haltsAll || question.type === 'EMERGENCY') {
      this.haltAll(question.id);
    } else if (question.haltsSession || question.type === 'APPROVAL') {
      if (question.sessionId) {
        this.haltSession(question.sessionId, question.id);
      }
      this.haltAgent(question.agentId, question.id);
    } else {
      this.haltAgent(question.agentId, question.id);
    }
  }

  async onQuestionAnswered(
    questionId: string,
    agentId: string,
    sessionId?: string,
    answer?: any
  ): Promise<void> {
    // Resume based on what was halted
    this.resumeAgent(agentId, answer);

    if (sessionId) {
      // Check if session has other blocking questions
      const otherBlocking = await this.getBlockingQuestions('*', sessionId);
      if (otherBlocking.length === 0) {
        this.resumeSession(sessionId, answer);
      }
    }

    // Check if system can resume
    const systemBlocking = await this.getSystemBlockingQuestions();
    if (systemBlocking.length === 0) {
      this.resumeAll(answer);
    }
  }

  private isHaltingQuestion(type: QuestionType): boolean {
    return ['BLOCKING', 'APPROVAL', 'EMERGENCY', 'ESCALATION'].includes(type);
  }

  private async getBlockingQuestions(
    agentId: string,
    sessionId?: string
  ): Promise<BlockingQuestion[]> {
    let query = `
      SELECT id, agent_id, session_id, type
      FROM questions
      WHERE status = 'pending'
        AND blocking = 1
    `;
    const params: any[] = [];

    if (agentId !== '*') {
      query += ' AND agent_id = ?';
      params.push(agentId);
    }

    if (sessionId) {
      query += ' AND session_id = ?';
      params.push(sessionId);
    }

    const results = await this.db.query(query, params);
    return results.map((r: any) => ({
      id: r.id,
      agentId: r.agent_id,
      sessionId: r.session_id,
      type: r.type,
      haltsSession: ['APPROVAL', 'EMERGENCY'].includes(r.type),
      haltsAll: r.type === 'EMERGENCY',
    }));
  }

  private async getSystemBlockingQuestions(): Promise<BlockingQuestion[]> {
    const results = await this.db.query(`
      SELECT id, agent_id, session_id, type
      FROM questions
      WHERE status = 'pending'
        AND type = 'EMERGENCY'
    `);
    return results as BlockingQuestion[];
  }
}
```

---

## Usage Example

```typescript
// In any agent's work loop

class SpecAgent {
  private executionGate: ExecutionGate;

  async doWork() {
    // Check before starting work
    const canProceed = await this.executionGate.canProceed(this.agentId, this.sessionId);

    if (!canProceed) {
      console.log('Agent halted, waiting for clearance...');

      const result = await this.executionGate.waitForClearance(
        this.agentId,
        this.sessionId,
        300_000 // 5 min timeout
      );

      if (!result.cleared) {
        throw new Error('Timed out waiting for clearance');
      }

      console.log('Clearance received, resuming work');
    }

    // Proceed with actual work
    await this.generateSpec();
  }
}
```

---

## Validation

```bash
npx tsc --noEmit server/communication/execution-gate.ts
npm test -- --grep "execution-gate"
```
