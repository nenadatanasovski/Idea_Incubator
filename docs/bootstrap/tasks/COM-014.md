# COM-014: Agent Communication Handshake

---

## Metadata

| Field | Value |
|-------|-------|
| **Phase** | 0 - Communication Core |
| **Depends On** | COM-002, COM-004, COM-010 |
| **Blocks** | All agent tasks (AGT-*, SPC-*, BLD-*, VAL-*, SIA-*) |
| **Priority** | P1 |
| **Owner** | Build Agent |

---

## Summary

Implement the agent communication handshake protocol that validates each agent can send/receive messages before it begins work.

---

## Context

### The Problem

When a new agent starts (or restarts), we need to guarantee:
1. It's registered with the correct Telegram bot
2. It can successfully send messages
3. The user has acknowledged the agent is online
4. The communication channel is healthy

Without this, an agent could silently fail to communicate, leading to:
- Unanswered blocking questions
- Missed approvals
- Silent failures

### The Handshake Flow

```
Agent Startup
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. REGISTER                                                     â”‚
â”‚     Agent calls communicationHub.register(agentId, agentType)   â”‚
â”‚     â†’ Assigned to correct bot (@vibe_spec_bot, etc.)            â”‚
â”‚     â†’ Added to active agents registry                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2. HELLO MESSAGE                                                â”‚
â”‚     Agent sends: "ğŸŸ¢ Agent spec-agent-123 is online"            â”‚
â”‚     â†’ Delivered via assigned bot                                 â”‚
â”‚     â†’ Includes agent type, session ID, capabilities             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. DELIVERY CONFIRMATION                                        â”‚
â”‚     System confirms message was delivered to Telegram/Email      â”‚
â”‚     â†’ If fails, retry with backoff                               â”‚
â”‚     â†’ If all retries fail, agent enters DEGRADED mode           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  4. USER ACKNOWLEDGMENT (optional, configurable)                 â”‚
â”‚     For critical agents (Monitoring, Orchestrator):              â”‚
â”‚     â†’ Wait for user to tap [Acknowledged] button                 â”‚
â”‚     â†’ Or auto-acknowledge after configurable timeout             â”‚
â”‚     For worker agents:                                           â”‚
â”‚     â†’ Auto-acknowledge after delivery confirmation               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  5. HANDSHAKE COMPLETE                                           â”‚
â”‚     Agent status: READY                                          â”‚
â”‚     Can now send questions and receive answers                   â”‚
â”‚     Heartbeat monitoring begins                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Requirements

1. **Registration**:
   - `register(agentId, agentType, sessionId?, capabilities?)` â†’ RegistrationResult
   - Assign agent to correct bot based on type
   - Store in active agents registry
   - Emit `agent:registered` event

2. **Hello Message**:
   - Send formatted startup message via assigned bot
   - Include: agent ID, type, session, start time, capabilities
   - Track delivery status

3. **Delivery Confirmation**:
   - Confirm Telegram API returned success
   - Retry with exponential backoff on failure
   - Fall back to email if Telegram fails
   - Enter DEGRADED mode if all channels fail

4. **User Acknowledgment**:
   - Configurable per agent type (require vs auto)
   - Inline button for explicit acknowledgment
   - Timeout with auto-acknowledge option
   - Log acknowledgment status

5. **Handshake State Machine**:
   - States: REGISTERING â†’ HELLO_SENT â†’ AWAITING_ACK â†’ READY | DEGRADED
   - Timeouts per state
   - Retry logic per state

6. **Health Check / Heartbeat**:
   - After handshake, periodic health check
   - If heartbeat fails, attempt re-handshake
   - Notify user of communication issues

---

## Pass Criteria

**PASS** when ALL of the following are true:

| # | Criterion | How to Verify |
|---|-----------|---------------|
| 1 | File exists | `test -f server/communication/agent-handshake.ts` returns 0 |
| 2 | Exports AgentHandshake | `grep -q "export class AgentHandshake" server/communication/agent-handshake.ts` returns 0 |
| 3 | Has register method | `grep -q "register(" server/communication/agent-handshake.ts` returns 0 |
| 4 | Has sendHello method | `grep -q "sendHello\|hello" server/communication/agent-handshake.ts` returns 0 |
| 5 | Has state machine | `grep -q "REGISTERING\|HELLO_SENT\|AWAITING_ACK\|READY\|DEGRADED" server/communication/agent-handshake.ts` returns 0 |
| 6 | Has heartbeat | `grep -q "heartbeat\|healthCheck" server/communication/agent-handshake.ts` returns 0 |
| 7 | TypeScript compiles | `npx tsc --noEmit server/communication/agent-handshake.ts` returns 0 |
| 8 | Unit tests pass | `npm test -- --grep "agent-handshake"` passes |

**FAIL** if any criterion is not met.

---

## Output Files

```
server/communication/
â””â”€â”€ agent-handshake.ts
```

---

## Code Template

```typescript
// server/communication/agent-handshake.ts

import { EventEmitter } from 'events';
import { BotRegistry, AgentType } from './bot-registry';
import { NotificationDispatcher } from './notification-dispatcher';
import { Database } from '../../database/db';

type HandshakeState =
  | 'REGISTERING'
  | 'HELLO_SENT'
  | 'AWAITING_ACK'
  | 'READY'
  | 'DEGRADED';

interface AgentCapabilities {
  canAskQuestions: boolean;
  canReceiveCommands: boolean;
  requiresApproval: boolean;
  heartbeatIntervalMs: number;
}

interface RegistrationResult {
  success: boolean;
  agentId: string;
  assignedBot: string;
  state: HandshakeState;
  error?: string;
}

interface HandshakeConfig {
  requireUserAck: boolean;          // Require explicit user acknowledgment
  ackTimeoutMs: number;             // Timeout before auto-ack (if allowed)
  autoAckOnTimeout: boolean;        // Auto-acknowledge on timeout
  helloRetries: number;             // Retries for hello message
  heartbeatIntervalMs: number;      // Heartbeat frequency
  heartbeatTimeoutMs: number;       // Heartbeat response timeout
}

// Default configs per agent type
const AGENT_CONFIGS: Record<AgentType, HandshakeConfig> = {
  MONITOR: {
    requireUserAck: true,           // Critical - require explicit ack
    ackTimeoutMs: 300_000,          // 5 min timeout
    autoAckOnTimeout: false,        // Don't auto-ack, keep waiting
    helloRetries: 5,
    heartbeatIntervalMs: 60_000,    // Every minute
    heartbeatTimeoutMs: 30_000,
  },
  ORCHESTRATOR: {
    requireUserAck: true,
    ackTimeoutMs: 300_000,
    autoAckOnTimeout: true,         // Auto-ack after 5 min
    helloRetries: 5,
    heartbeatIntervalMs: 60_000,
    heartbeatTimeoutMs: 30_000,
  },
  SPEC: {
    requireUserAck: false,          // Worker - auto-ack on delivery
    ackTimeoutMs: 60_000,
    autoAckOnTimeout: true,
    helloRetries: 3,
    heartbeatIntervalMs: 300_000,   // Every 5 min
    heartbeatTimeoutMs: 60_000,
  },
  BUILD: {
    requireUserAck: false,
    ackTimeoutMs: 60_000,
    autoAckOnTimeout: true,
    helloRetries: 3,
    heartbeatIntervalMs: 300_000,
    heartbeatTimeoutMs: 60_000,
  },
  VALIDATION: {
    requireUserAck: false,
    ackTimeoutMs: 60_000,
    autoAckOnTimeout: true,
    helloRetries: 3,
    heartbeatIntervalMs: 300_000,
    heartbeatTimeoutMs: 60_000,
  },
  SIA: {
    requireUserAck: false,
    ackTimeoutMs: 60_000,
    autoAckOnTimeout: true,
    helloRetries: 3,
    heartbeatIntervalMs: 300_000,
    heartbeatTimeoutMs: 60_000,
  },
  SYSTEM: {
    requireUserAck: false,
    ackTimeoutMs: 30_000,
    autoAckOnTimeout: true,
    helloRetries: 5,
    heartbeatIntervalMs: 60_000,
    heartbeatTimeoutMs: 30_000,
  },
};

interface ActiveAgent {
  agentId: string;
  agentType: AgentType;
  sessionId?: string;
  capabilities: AgentCapabilities;
  state: HandshakeState;
  assignedBot: string;
  registeredAt: Date;
  lastHeartbeat: Date;
  ackReceived: boolean;
  ackReceivedAt?: Date;
}

export class AgentHandshake extends EventEmitter {
  private db: Database;
  private botRegistry: BotRegistry;
  private dispatcher: NotificationDispatcher;
  private activeAgents: Map<string, ActiveAgent> = new Map();
  private heartbeatTimers: Map<string, NodeJS.Timer> = new Map();

  constructor(
    db: Database,
    botRegistry: BotRegistry,
    dispatcher: NotificationDispatcher
  ) {
    super();
    this.db = db;
    this.botRegistry = botRegistry;
    this.dispatcher = dispatcher;
  }

  async register(
    agentId: string,
    agentType: AgentType,
    sessionId?: string,
    capabilities?: Partial<AgentCapabilities>
  ): Promise<RegistrationResult> {
    console.log(`[Handshake] Registering agent: ${agentId} (${agentType})`);

    // Get assigned bot
    const bot = this.botRegistry.getBot(agentType);
    if (!bot) {
      return {
        success: false,
        agentId,
        assignedBot: '',
        state: 'DEGRADED',
        error: `No bot configured for agent type: ${agentType}`,
      };
    }

    // Create agent record
    const config = AGENT_CONFIGS[agentType];
    const agent: ActiveAgent = {
      agentId,
      agentType,
      sessionId,
      capabilities: {
        canAskQuestions: true,
        canReceiveCommands: true,
        requiresApproval: agentType === 'MONITOR',
        heartbeatIntervalMs: config.heartbeatIntervalMs,
        ...capabilities,
      },
      state: 'REGISTERING',
      assignedBot: bot.username,
      registeredAt: new Date(),
      lastHeartbeat: new Date(),
      ackReceived: false,
    };

    this.activeAgents.set(agentId, agent);
    this.emit('agent:registered', { agentId, agentType, assignedBot: bot.username });

    // Persist to database
    await this.persistAgent(agent);

    // Send hello message
    const helloResult = await this.sendHello(agent);
    if (!helloResult.success) {
      agent.state = 'DEGRADED';
      this.emit('agent:degraded', { agentId, reason: 'hello_failed' });
      return {
        success: false,
        agentId,
        assignedBot: bot.username,
        state: 'DEGRADED',
        error: helloResult.error,
      };
    }

    agent.state = 'HELLO_SENT';

    // Handle acknowledgment
    if (config.requireUserAck) {
      agent.state = 'AWAITING_ACK';
      this.startAckTimeout(agent, config);
    } else {
      // Auto-acknowledge on delivery
      agent.state = 'READY';
      agent.ackReceived = true;
      agent.ackReceivedAt = new Date();
      this.emit('agent:ready', { agentId, agentType });
    }

    // Start heartbeat
    this.startHeartbeat(agent);

    return {
      success: true,
      agentId,
      assignedBot: bot.username,
      state: agent.state,
    };
  }

  private async sendHello(agent: ActiveAgent): Promise<{ success: boolean; error?: string }> {
    const config = AGENT_CONFIGS[agent.agentType];
    const message = this.formatHelloMessage(agent);

    for (let attempt = 1; attempt <= config.helloRetries; attempt++) {
      try {
        const result = await this.dispatcher.notify({
          agentId: agent.agentId,
          agentType: agent.agentType,
          type: 'ALERT',
          content: message,
          options: config.requireUserAck
            ? [{ label: 'Acknowledged', action: 'ack' }]
            : undefined,
          metadata: {
            isHandshake: true,
            handshakeType: 'hello',
          },
        });

        if (result.delivered) {
          console.log(`[Handshake] Hello sent for ${agent.agentId} (attempt ${attempt})`);
          return { success: true };
        }
      } catch (error) {
        console.error(`[Handshake] Hello failed for ${agent.agentId} (attempt ${attempt}):`, error);
      }

      // Exponential backoff
      if (attempt < config.helloRetries) {
        await this.sleep(1000 * Math.pow(2, attempt - 1));
      }
    }

    return { success: false, error: 'All hello attempts failed' };
  }

  private formatHelloMessage(agent: ActiveAgent): string {
    const emoji = agent.agentType === 'MONITOR' ? 'ğŸŸ¢' : 'ğŸ‘‹';
    let msg = `${emoji} *Agent Online*\n\n`;
    msg += `Agent: \`${agent.agentId}\`\n`;
    msg += `Type: ${agent.agentType}\n`;
    if (agent.sessionId) {
      msg += `Session: \`${agent.sessionId}\`\n`;
    }
    msg += `Started: ${agent.registeredAt.toLocaleTimeString()}\n`;

    if (AGENT_CONFIGS[agent.agentType].requireUserAck) {
      msg += `\n_Tap [Acknowledged] to confirm you're receiving messages from this agent._`;
    }

    return msg;
  }

  private startAckTimeout(agent: ActiveAgent, config: HandshakeConfig): void {
    setTimeout(async () => {
      if (!agent.ackReceived) {
        if (config.autoAckOnTimeout) {
          console.log(`[Handshake] Auto-acknowledging ${agent.agentId} after timeout`);
          agent.state = 'READY';
          agent.ackReceived = true;
          agent.ackReceivedAt = new Date();
          this.emit('agent:ready', { agentId: agent.agentId, agentType: agent.agentType, autoAck: true });
        } else {
          console.log(`[Handshake] ${agent.agentId} still awaiting acknowledgment`);
          this.emit('agent:awaiting_ack', { agentId: agent.agentId, agentType: agent.agentType });
          // Retry hello
          await this.sendHello(agent);
        }
      }
    }, config.ackTimeoutMs);
  }

  async acknowledgeAgent(agentId: string): Promise<boolean> {
    const agent = this.activeAgents.get(agentId);
    if (!agent) {
      console.error(`[Handshake] Unknown agent: ${agentId}`);
      return false;
    }

    if (agent.state !== 'AWAITING_ACK') {
      console.log(`[Handshake] Agent ${agentId} not awaiting ack (state: ${agent.state})`);
      return false;
    }

    agent.ackReceived = true;
    agent.ackReceivedAt = new Date();
    agent.state = 'READY';

    console.log(`[Handshake] Agent ${agentId} acknowledged by user`);
    this.emit('agent:ready', { agentId, agentType: agent.agentType, userAck: true });

    return true;
  }

  private startHeartbeat(agent: ActiveAgent): void {
    const config = AGENT_CONFIGS[agent.agentType];

    const timer = setInterval(async () => {
      await this.healthCheck(agent.agentId);
    }, config.heartbeatIntervalMs);

    this.heartbeatTimers.set(agent.agentId, timer);
  }

  async healthCheck(agentId: string): Promise<boolean> {
    const agent = this.activeAgents.get(agentId);
    if (!agent) {
      return false;
    }

    const config = AGENT_CONFIGS[agent.agentType];

    try {
      // Simple ping - just update last heartbeat
      // In production, this might verify Telegram API is reachable
      agent.lastHeartbeat = new Date();
      this.emit('agent:heartbeat', { agentId, timestamp: agent.lastHeartbeat });
      return true;
    } catch (error) {
      console.error(`[Handshake] Heartbeat failed for ${agentId}:`, error);

      // Check if agent has been unresponsive too long
      const timeSinceLastHeartbeat = Date.now() - agent.lastHeartbeat.getTime();
      if (timeSinceLastHeartbeat > config.heartbeatTimeoutMs) {
        agent.state = 'DEGRADED';
        this.emit('agent:degraded', { agentId, reason: 'heartbeat_timeout' });

        // Attempt re-handshake
        await this.sendHello(agent);
      }

      return false;
    }
  }

  async unregister(agentId: string): Promise<void> {
    const agent = this.activeAgents.get(agentId);
    if (!agent) {
      return;
    }

    // Stop heartbeat
    const timer = this.heartbeatTimers.get(agentId);
    if (timer) {
      clearInterval(timer);
      this.heartbeatTimers.delete(agentId);
    }

    // Send goodbye message
    await this.dispatcher.notify({
      agentId,
      agentType: agent.agentType,
      type: 'ALERT',
      content: `ğŸ”´ *Agent Offline*\n\nAgent: \`${agentId}\`\nStopped: ${new Date().toLocaleTimeString()}`,
    });

    // Remove from registry
    this.activeAgents.delete(agentId);
    this.emit('agent:unregistered', { agentId });

    console.log(`[Handshake] Agent ${agentId} unregistered`);
  }

  getAgentState(agentId: string): HandshakeState | null {
    const agent = this.activeAgents.get(agentId);
    return agent?.state || null;
  }

  isAgentReady(agentId: string): boolean {
    const agent = this.activeAgents.get(agentId);
    return agent?.state === 'READY';
  }

  getActiveAgents(): ActiveAgent[] {
    return Array.from(this.activeAgents.values());
  }

  getAgentsByState(state: HandshakeState): ActiveAgent[] {
    return Array.from(this.activeAgents.values()).filter(a => a.state === state);
  }

  private async persistAgent(agent: ActiveAgent): Promise<void> {
    await this.db.query(`
      INSERT INTO active_agents (
        agent_id, agent_type, session_id, state, assigned_bot,
        registered_at, last_heartbeat, ack_received
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      ON CONFLICT(agent_id) DO UPDATE SET
        state = excluded.state,
        last_heartbeat = excluded.last_heartbeat,
        ack_received = excluded.ack_received
    `, [
      agent.agentId,
      agent.agentType,
      agent.sessionId || null,
      agent.state,
      agent.assignedBot,
      agent.registeredAt.toISOString(),
      agent.lastHeartbeat.toISOString(),
      agent.ackReceived ? 1 : 0,
    ]);
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

---

## Database Schema

```sql
-- Add to migrations
CREATE TABLE IF NOT EXISTS active_agents (
  agent_id TEXT PRIMARY KEY,
  agent_type TEXT NOT NULL,
  session_id TEXT,
  state TEXT NOT NULL,
  assigned_bot TEXT NOT NULL,
  registered_at TEXT NOT NULL,
  last_heartbeat TEXT NOT NULL,
  ack_received INTEGER DEFAULT 0,
  ack_received_at TEXT,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_active_agents_state ON active_agents(state);
CREATE INDEX idx_active_agents_type ON active_agents(agent_type);
```

---

## Usage Example

```typescript
// In any agent's startup

class SpecAgent {
  private handshake: AgentHandshake;
  private agentId: string;

  async start() {
    // Step 1: Register and handshake
    const result = await this.handshake.register(
      this.agentId,
      'SPEC',
      this.sessionId,
      { canAskQuestions: true }
    );

    if (!result.success) {
      console.error(`Failed to register: ${result.error}`);
      // Handle degraded mode or exit
      return;
    }

    if (result.state !== 'READY') {
      console.log(`Agent state: ${result.state}, waiting...`);
      // Wait for ready event
      await this.waitForReady();
    }

    console.log(`Agent ready, assigned to ${result.assignedBot}`);

    // Step 2: Now can proceed with actual work
    await this.doWork();
  }

  private waitForReady(): Promise<void> {
    return new Promise((resolve) => {
      this.handshake.on('agent:ready', ({ agentId }) => {
        if (agentId === this.agentId) {
          resolve();
        }
      });
    });
  }

  async shutdown() {
    await this.handshake.unregister(this.agentId);
  }
}
```

---

## Validation

```bash
npx tsc --noEmit server/communication/agent-handshake.ts
npm test -- --grep "agent-handshake"
```
