# MON-007: Action Executor

---

## Metadata

| Field | Value |
|-------|-------|
| **Phase** | 2 - Monitoring Agent |
| **Depends On** | MON-006 |
| **Blocks** | MON-009 |
| **Priority** | P1 |
| **Owner** | Human (then Build Agent) |

---

## Summary

Implement the Action Executor that uses observe-confirm-act pattern with state versioning to safely execute monitoring actions.

---

## Requirements

1. **Observe-Confirm-Act Pattern**:
   - Initial observation
   - Wait (let transient issues resolve)
   - Confirm observation still valid
   - Check state version (optimistic locking)
   - Execute action
   - Cooldown before next observation

2. **Action Types**:
   - Log/Alert: Immediate, no confirmation
   - Warn: Submit to question queue
   - Pause: Via event bus
   - Restart: Via orchestration API
   - Kill/Emergency: Via question queue (human approval)

3. **Version Guards**:
   - Reject action if state version changed
   - Re-evaluate if state changed during confirmation

---

## Pass Criteria

**PASS** when ALL of the following are true:

| # | Criterion | How to Verify |
|---|-----------|---------------|
| 1 | File exists | `test -f agents/monitoring/action-executor.ts` returns 0 |
| 2 | Exports ActionExecutor | `grep -q "export class ActionExecutor" agents/monitoring/action-executor.ts` returns 0 |
| 3 | Has execute method | `grep -q "execute(" agents/monitoring/action-executor.ts` returns 0 |
| 4 | Has observe-confirm pattern | `grep -q "confirm\|observation" agents/monitoring/action-executor.ts` returns 0 |
| 5 | Has version checking | `grep -q "stateVersion\|versionMismatch" agents/monitoring/action-executor.ts` returns 0 |
| 6 | Has cooldown | `grep -q "cooldown" agents/monitoring/action-executor.ts` returns 0 |
| 7 | TypeScript compiles | `npx tsc --noEmit agents/monitoring/action-executor.ts` returns 0 |
| 8 | Unit tests pass | `npm test -- --grep "action-executor"` passes |

**FAIL** if any criterion is not met.

---

## Output Files

```
agents/monitoring/
└── action-executor.ts
```

---

## Code Template

```typescript
// agents/monitoring/action-executor.ts

import { ResponseDecision, ResponseLevel } from './response-escalator';
import { DetectedIssue } from './detection-engine';
import { EventBus } from '../../server/orchestration/event-bus';

export interface ExecutionResult {
  success: boolean;
  action: ResponseLevel;
  agentId: string;
  versionMismatch: boolean;
  error?: string;
  executedAt: Date;
}

export interface ActionConfig {
  confirmationDelay: number;  // ms to wait before confirming
  cooldownPeriod: number;     // ms to wait after action
}

export class ActionExecutor {
  private config: ActionConfig;
  private eventBus: EventBus;
  private questionQueue: QuestionQueue;
  private lastActionTime: Map<string, Date> = new Map();

  constructor(config: ActionConfig, eventBus: EventBus, questionQueue: QuestionQueue) {
    this.config = config;
    this.eventBus = eventBus;
    this.questionQueue = questionQueue;
  }

  async execute(response: ResponseDecision): Promise<ExecutionResult> {
    const { level, action, issue } = response;

    // Check cooldown
    if (this.isInCooldown(issue.agentId, action.cooldown)) {
      return {
        success: false,
        action: level,
        agentId: issue.agentId,
        versionMismatch: false,
        error: 'In cooldown period',
        executedAt: new Date(),
      };
    }

    // Immediate actions (no confirmation)
    if (level <= ResponseLevel.ALERT) {
      return this.executeImmediate(response);
    }

    // Actions requiring confirmation
    return this.executeWithConfirmation(response);
  }

  private async executeImmediate(response: ResponseDecision): Promise<ExecutionResult> {
    const { level, issue } = response;

    switch (level) {
      case ResponseLevel.OBSERVE:
        // Do nothing, already logged
        break;
      case ResponseLevel.LOG:
        this.log(issue);
        break;
      case ResponseLevel.ALERT:
        await this.alert(issue);
        break;
    }

    return {
      success: true,
      action: level,
      agentId: issue.agentId,
      versionMismatch: false,
      executedAt: new Date(),
    };
  }

  private async executeWithConfirmation(response: ResponseDecision): Promise<ExecutionResult> {
    const { level, action, issue } = response;

    // Step 1: Initial observation
    const observation1 = await this.observe(issue.agentId);

    if (!this.issueStillPresent(observation1, issue)) {
      return {
        success: false,
        action: level,
        agentId: issue.agentId,
        versionMismatch: false,
        error: 'Issue resolved before action',
        executedAt: new Date(),
      };
    }

    // Step 2: Wait
    await this.wait(action.requiresConfirmation ? this.config.confirmationDelay : 0);

    // Step 3: Confirm observation
    const observation2 = await this.observe(issue.agentId);

    if (!this.issueStillPresent(observation2, issue)) {
      return {
        success: false,
        action: level,
        agentId: issue.agentId,
        versionMismatch: false,
        error: 'Issue resolved during confirmation',
        executedAt: new Date(),
      };
    }

    // Step 4: Version check
    if (observation2.stateVersion !== observation1.stateVersion) {
      return {
        success: false,
        action: level,
        agentId: issue.agentId,
        versionMismatch: true,
        error: 'State version changed, re-evaluating',
        executedAt: new Date(),
      };
    }

    // Step 5: Execute action
    let result: ExecutionResult;

    if (action.humanApprovalRequired) {
      result = await this.executeWithHumanApproval(response, observation2.stateVersion);
    } else {
      result = await this.executeDirectly(response, observation2.stateVersion);
    }

    // Step 6: Record and cooldown
    this.lastActionTime.set(issue.agentId, new Date());

    return result;
  }

  private async executeWithHumanApproval(
    response: ResponseDecision,
    expectedVersion: number
  ): Promise<ExecutionResult> {
    const { level, issue } = response;

    // Submit to question queue
    const question = await this.questionQueue.submitQuestion({
      type: 'APPROVAL',
      agentId: 'monitoring-agent',
      content: this.buildApprovalQuestion(response),
      options: [
        { label: 'Yes, proceed', action: 'proceed' },
        { label: 'No, ignore', action: 'ignore' },
        { label: 'Pause instead', action: 'pause' },
      ],
      priority: 95,
      blocking: true,
      context: { issue, expectedVersion },
    });

    // Wait for answer
    const answer = await question.waitForAnswer();

    if (answer.action === 'proceed') {
      return this.executeDirectly(response, expectedVersion);
    }

    if (answer.action === 'pause') {
      return this.executeDirectly({
        ...response,
        level: ResponseLevel.PAUSE,
      }, expectedVersion);
    }

    return {
      success: false,
      action: level,
      agentId: issue.agentId,
      versionMismatch: false,
      error: 'Human declined action',
      executedAt: new Date(),
    };
  }

  private async executeDirectly(
    response: ResponseDecision,
    expectedVersion: number
  ): Promise<ExecutionResult> {
    const { level, issue } = response;

    try {
      switch (level) {
        case ResponseLevel.WARN:
          await this.warn(issue);
          break;
        case ResponseLevel.PAUSE:
          await this.pause(issue.agentId, expectedVersion);
          break;
        case ResponseLevel.RESTART:
          await this.restart(issue.agentId, expectedVersion);
          break;
        case ResponseLevel.KILL:
          await this.kill(issue.agentId, expectedVersion);
          break;
        case ResponseLevel.EMERGENCY:
          await this.emergency(expectedVersion);
          break;
      }

      return {
        success: true,
        action: level,
        agentId: issue.agentId,
        versionMismatch: false,
        executedAt: new Date(),
      };
    } catch (error) {
      return {
        success: false,
        action: level,
        agentId: issue.agentId,
        versionMismatch: false,
        error: error.message,
        executedAt: new Date(),
      };
    }
  }

  private async pause(agentId: string, expectedVersion: number): Promise<void> {
    this.eventBus.publish('agent_pause_requested', {
      agentId,
      expectedVersion,
      reason: 'monitoring_agent_action',
    });
  }

  private async restart(agentId: string, expectedVersion: number): Promise<void> {
    this.eventBus.publish('agent_restart_requested', {
      agentId,
      expectedVersion,
      reason: 'monitoring_agent_action',
    });
  }

  // ... other action implementations

  private isInCooldown(agentId: string, cooldown: number): boolean {
    const lastAction = this.lastActionTime.get(agentId);
    if (!lastAction) return false;
    return Date.now() - lastAction.getTime() < cooldown;
  }

  private wait(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

---

## Validation

```bash
npx tsc --noEmit agents/monitoring/action-executor.ts
npm test -- --grep "action-executor"
```
